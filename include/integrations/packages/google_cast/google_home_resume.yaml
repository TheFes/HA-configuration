# Scripts and automation to resume streams on Google Home speakes after it has been interrupted by service calls
# Supports resuming of Spotify and online streams (like TuneIn)
# Package contains 3 main scripts, the helper script to perform the resume and supporting template sensor and automation
# for more details:
#
## Google Home Resume: https://github.com/TheFes/HA-configuration/blob/main/include/script/00_general/google_cast/docs/google_home_resume.md
## Google Home Event: https://github.com/TheFes/HA-configuration/blob/main/include/integrations/packages/google_cast/docs/google_home_event.md
## Google Home Voice: https://github.com/TheFes/HA-configuration/blob/main/include/integrations/packages/google_cast/docs/google_home_voice.md

homeassistant:
  customize:
    script.google_home_resume:
      # enter settings for the script here, all settings are optional, you can remove sections if you don't need them
      # always leave the line with "settings: &settings" in!
      settings: &settings
        primary_spotcast: "pepijn"
        radio_data:
          NPO Radio 2:
            picture: "http://192.168.2.3:8123/local/pictures/radio/npo_radio_2.png"
            title: "Er is maar één NPO Radio 2"
          Radio Veronica:
            picture: "http://192.168.2.3:8123/local/pictures/radio/radio_veronica.png"
            title: "WE. LOVE. MUSIC."
          Willy:
            picture: "http://192.168.2.3:8123/local/pictures/radio/willy.png"
            title: "MUSIC MATTERS"
          KINK:
            picture: "http://192.168.2.3:8123/local/pictures/radio/kink.jpg"
            title: "NO ALTERNATIVE"
        speaker_groups:
          media_player.huis_groep:
            - media_player.keuken_hub
            - media_player.slaapkamer_hub
            - media_player.pepijn_mini
            - media_player.woonkamer_home
            - media_player.werkamer_marleen_minini
            - media_player.zolder_werkkamer_stereo
            - media_player.floris_mini
          media_player.boven_groep:
            - media_player.pepijn_mini
            - media_player.slaapkamer_hub
            - media_player.werkamer_marleen_mini
            - media_player.zolder_werkkamer_stereo
            - media_player.floris_mini
          media_player.beneden_groep:
            - media_player.keuken_hub
            - media_player.woonkamer_home
          media_player.zolder_groep:
            - media_player.slaapkamer_hub
            - media_player.zolder_werkkamer_stereo
        default_volume_level: 0.25
        dummy_player: media_player.vlc_telnet
        default_resume_delay:
          seconds: 20
        max_runtime:
          minutes: 10
        # settings for automation
        enable_automation: true
        dashboard_cast: true
        announce_volume_automation: 0.4
      # settings for voice script
      voice_settings: &voice_settings
        check_for_title: "Witte ruis"
        use_resume: true

#### TO UPDATE TO A NEW VERSION, REPLACE EVERYTHING BELOW THIS LINE ####

# Group integration, to make sure the dynamic groups can be created
group:

# All the Google Home scripts, now in one package
script:
  # The main Google Home Resume script
  google_home_resume:
    alias: "00 - Google Home Resume"
    description: Script for resuming Google Home speakers
    icon: mdi:cast-audio
    mode: parallel
    fields:
      target:
        description: "Enter the targets in case they are not clear from the service calls"
        required: false
        selector:
          target:
            entity:
              integration: cast
              domain: media_player
            device:
              integration: cast
      action:
        description: "Actions to be performed (only service calls will work)"
        required: true
        selector:
          action:
      resume_this_action:
        description: "Set to false if you don't want to resume the actions started with this script (default is true)"
        required: false
        selector:
          boolean:
      resume_delay:
        description: "Delay before resume when casting an image or dashboard. Default value is set by default_resume_delay variable or 20 seconds."
        required: false
        selector:
          duration:
    variables:
      settings: *settings
    sequence:
      - alias: "Version number"
        variables: &version
          version: &ver 2023.6.1
          settings: "{{ settings | default({}, true) }}"
      - alias: "Failsafe to remove all groups if the script was not running"
        if: >
          {{ 
            state_attr(this.entity_id, 'current') == 1
            and integration_entities('group')
                  | select('search', 'ghresume')
                  | list | count > 0
          }}
        then:
          - alias: "Which groups to remove"
            variables:
              groups_existing: >
                {{ integration_entities('group') | select('search', 'ghresume') | list }}
          - alias: "Loop to remove groups"
            repeat:
              for_each: "{{ groups_existing }}"
              sequence:
                - alias: "Remove one group"
                  service: group.remove
                  data:
                    object_id: "{{ states[repeat.item].object_id }}"
      - alias: "Set based on other scripts"
        variables:
          event_script: "{{ event_script | default(false) }}"
          automation: "{{ automation | default(false) }}"
      - alias: "Set variables for service calls"
        variables: &service_vars
          service_calls: >
            {% set action = action | default([]) %}
            {{ iif(action is mapping,[ action ], action) | selectattr('service', 'defined') | list }}
          no_service_count: >
            {% set action = action | default([]) %}
            {{ iif(action is mapping,[ action ], action) | count - service_calls | count }}
      - alias: "Wrong actions provided"
        choose:
          - conditions: "{{ not (event_script or automation) and service_calls | count == 0 }}"
            sequence:
              - stop: "There were no service calls defined, no actions are performed. The script script has been aborted."
                error: true
          - conditions: "{{ not (event_script or automation) and no_service_count > 0 }}"
            sequence:
              - service: system_log.write
                data:
                  level: "warning"
                  logger: "{{ this.entity_id }}"
                  message: >
                    {{ no_service_count }} out of {{ service_calls | count }} actions were not performed because they are not service calls.
      - alias: "Set variables to be used in the script"
        variables: &generic_vars
          start_time: "{{ start_time if start_time is defined else now() }}"
          speaker_groups: "{{ settings.get('speaker_groups') | default({}, true) }}"
          speaker_group_list: "{{ speaker_groups.keys() | list }}"
          cast_entities: "{{ integration_entities('cast') }}"
          spotify_entities: "{{ integration_entities('spotify') }}"
          mass_entities: "{{ integration_entities('mass') | select('match', '^media_player.') | list }}"
          cast_mass_playing: >
            {%- if cast_mass_playing is defined %}
              {{ cast_mass_playing }}
            {%- else %}
              {{
                expand(integration_entities('cast'))
                  | selectattr('attributes.media_title', 'defined')
                  | selectattr('attributes.media_title', 'search', 'Streaming from Music Assistant')
                  | map(attribute='entity_id')
                  | list
              }}
            {%- endif %}
          mass_playing: "{{ cast_mass_playing | map('replace', '.', '.mass_') | select() | list }}"
          primary_spotcast_check: >
            {%- set accounts = spotify_entities | map('replace', 'media_player.spotify_', '') | list %}
            {{ spotify_entities | count <= 1 or settings.get('primary_spotcast') in accounts }}
          ytube_music_entities: >
            {{ integration_entities('ytube_music_player') | select('match', '^media_player.') | list }}
          resume_active: >
            {{ expand(integration_entities('group'))
                | selectattr('entity_id', 'search', 'group.resume_active_ghresume')
                | map(attribute='attributes.entity_id')
                | map('list')
                | sum(start=[])
            }}
          resume_action_false: >
            {{ expand(integration_entities('group'))
                | selectattr('entity_id', 'search', 'group.resume_action_false_ghresume')
                | map(attribute='attributes.entity_id')
                | map('list')
                | sum(start=[])
            }}
      - alias: "Update Spotify data if there are Spotify entities"
        if: "{{ spotify_entities | count > 0 }}"
        then:
          - alias: "Update Spotify entities"
            service: homeassistant.update_entity
            target:
              entity_id: "{{ spotify_entities }}"
      - alias: "Store data of media player entities and determine target_list"
        variables:
          data_source: resume_script
      - variables:
          player_data: &player_data >
            {%- if player_data is undefined %}
              {# general information for all entities #}
              {%- set ns = namespace(info=[], groups_playing=[]) %}
              {%- for entity in expand(cast_entities) %}
                  {%- set members = speaker_groups[entity.entity_id]
                                if speaker_groups is defined
                                  and iif(speaker_groups)
                                  and entity.entity_id in speaker_group_list
                                else []
                  %}
                  {%- set screen = entity.attributes.device_class is not defined %}
                  {%- set type = iif(members,'group',iif(screen,'screen','speaker')) %}
                  {%- for group in speaker_group_list %}
                    {%- set members = speaker_groups.items() | selectattr('0', 'eq', group) | map(attribute='1') | list | first %}
                    {%- set members_playing = expand(members) | selectattr('state', 'eq', 'playing') | list | count == members | count %}
                    {%- set content_list = expand(members) | selectattr('attributes.media_content_id', 'defined') | map(attribute='attributes.media_content_id') | list %}
                    {%- set group_playing = members_playing and content_list | select('eq', content_list[0]) | list | count == content_list | count %}
                    {%- set ns.groups_playing = ns.groups_playing + [ group ] if group_playing else ns.groups_playing %}
                  {%- endfor %}
                  {%- set groups_playing = ns.groups_playing %}
                  {%- if type == 'speaker' %}
                    {% set groups = speaker_groups.items() | selectattr('1', 'search', entity.entity_id) | map(attribute='0') | list %}
                    {% set playing = groups | select('in', groups_playing) | list | count > 0 %}
                    {% set type = 'playing_member' if playing else type %}
                  {%- endif %}
                  {%- set state = 'off' if type == 'group' and not entity.entity_id in groups_playing else entity.state %}
                  {%- set general = dict(
                                          data_source = data_source,
                                          entity_id = entity.entity_id,
                                          state = state,
                                          type = type,
                                          members = members
                                          )
                                    if type != 'playing_member'
                                    else dict(entity_id = entity.entity_id, type = type, members=[])
                  %}
                  {# add information for Music Assistant #}
                  {%- if mass_entities | count > 0 and type != 'playing_member' %}
                    {%- set mass_data = dict(
                                              mass_playing = entity.entity_id in cast_mass_playing,
                                              mass_sync = entity.entity_id | replace('.', '.mass_')
                                            )
                    %}
                    {%- set general = dict(general, **mass_data) %}
                  {%- endif %}
                  {# check if there is a Spotify account playing on this entity #}
                  {%- set list_check = expand([ entity.entity_id ] + members) | map(attribute='name') | list %}
                  {%- set spotify_entity = expand(spotify_entities)
                                              | selectattr('state', 'eq', 'playing')
                                              | selectattr('attributes.source', 'in', list_check)
                                              | map(attribute='object_id')
                                              | join
                                              | replace('spotify_', '')
                  %}
                  {# add volume level #}
                  {%- if not state in ['off', 'unavailable', 'unknown'] or type == 'playing_member' %}
                    {%- set additional = dict(volume_level = entity.attributes.get('volume_level', settings.get('default_volume_level')) | round(2, default=0.25)) %}
                  {%- else %}
                    {%- set additional = {} %}
                  {%- endif %}
                  {# add metadata for playing entities #}
                  {%- if type == 'playing_member'%}
                  {%- elif (spotify_entity or
                          (
                            entity.state == 'playing'
                            and expand(speaker_groups.items()
                                        | selectattr('0', 'eq', entity.entity_id)
                                        | list) 
                                          | rejectattr('state', 'eq', 'playing')
                                          | list
                                          | count == 0
                          )) and (type != 'group' or entity.entity_id in groups_playing)
                  %}
                    {%- set additional = dict(additional, **dict(
                                              state = 'playing',
                                              app_name = entity.attributes.get('app_name', 'no app'),
                                              media_content_id = (entity.attributes.get('media_content_id', {}) | from_json).get('contentId', 'no media_content')
                                                                  if entity.attributes.get('app_name') == 'Google Podcasts'
                                                                  else entity.attributes.get('media_content_id', 'no media_content'),
                                              media_position = (as_timestamp(now()) | round(2)
                                                                - as_timestamp(entity.attributes.get('media_position_updated_at', now())) | round(2)
                                                                + entity.attributes.get('media_position', 0)) | round(2)
                                              ))
                    %}
                    {# add Spotify account #}
                    {%- if entity.attributes.get('app_name') == 'Spotify' %}
                      {%- set spotcast = spotify_entity if spotify_entity
                                                and settings.primary_spotcast is defined
                                                and spotify_entity != settings.primary_spotcast
                                                and spotify_entities | count > 1
                                                and primary_spotcast_check
                                              else 'primary_account' %}
                      {%- set additional = dict(additional,
                                                **dict(state='playing',
                                                        spotcast = spotcast
                                                      )
                                              ) 
                      %}
                    {# add information for ytube_music_player integration #}
                    {%- elif entity.entity_id in expand(ytube_music_entities)
                                                  | selectattr('state', 'eq', 'playing')
                                                  | selectattr('attributes.remote_player_id', 'defined')
                                                  | map(attribute='attributes.remote_player_id')
                                                  | list
                    %}
                      {%- set additional = dict(additional,
                                                **dict(app_name='Ytube Music Player',
                                                        yt_player=expand(ytube_music_entities) | selectattr('attributes.remote_player_id', 'defined') | selectattr('attributes.remote_player_id', 'eq', entity.entity_id) | map(attribute='entity_id') | join,
                                                        media_content_id = 'ytube_music'
                                                      )
                                              ) 
                      %}
                    {# add information for web streams (including TuneIn) #}
                    {%- elif entity.attributes.get('app_name') not in ['Spotify', 'YouTube', 'YouTube Music'] %}
                      {%- if entity.attributes.get('media_artist') in (settings.get('radio_data') | default({}, true)).keys() | list %}
                        {%- set data = settings.radio_data[entity.attributes.media_artist] %}
                        {%- set picture, title = data.get('picture'), data.get('title') %}
                      {%- endif %}
                      {%- set additional = dict(additional, **dict(
                                                    media_artist = 'Google Podcasts' if entity.attributes.get('app_name') == 'Google Podcasts'
                                                                    else entity.attributes.get('media_artist', 'no artist'),
                                                    media_title = title if title is defined else entity.attributes.get('media_title', 'no title'),
                                                    media_content_type = '' ~ entity.attributes.get('media_content_type', 'no type'),
                                                    entity_picture = picture if picture is defined else entity.attributes.get('entity_picture', 'no pic')
                                                    ))
                      %}
                    {%- endif %}
                  {%- endif %}
                {# cobmine all data #}
                {%- set ns.info = ns.info + [ dict(general, **additional) if additional is defined else general ] %}
              {%- endfor %}
              {% set player_data = ns.info %}
            {%- endif %}
            {{ player_data }}
      - variables:
          target_list: >
            {%- if target_list is defined %}
              {%- set total_list = target_list %}
            {%- else %}
              {# create target lists #}
              {# define target and entities_check variables #}
                {%- set target = target | default({}, true) %}
                {%- set entities_check = cast_entities + mass_entities %}
              {# create lists based on target input #}
                {%- set a = target.get('area_id', []) %}
                {%- set d = target.get('device_id', []) %}
                {%- set e = target.get('entity_id', []) %}
                {%- set a = (a | replace(' ', '')).split(',') if a is string else a %}
                {%- set d = (d | replace(' ', '')).split(',') if d is string else d %}
                {%- set e = ((e | replace(' ', '')).split(',') if e is string else e) | select('in', cast_entities) | list %}
              {# add targets based on actions #}
                {# entities #}
                  {%- set ns = namespace(e=e) %}
                  {%- for call in service_calls %}
                    {%- set e2 = [
                                call.get('entity_id', []),
                                call.get('data', {}).get('entity_id', []),
                                call.get('target', {}).get('entity_id', []),
                                call.get('extra', {}).get('entity_id', []),
                                call.get('data', {}).get('script_extra', {}).get('entity_id', [])
                              ] %}
                    {%- set e2 = ([e2 | select('string') | join(',')] | reject('string') | sum(start=[])) | join(',') %}
                    {%- set ns.e = [ns.e, e2 ] | select() | join(',') %}
                  {%- endfor %}
                  {%- set entity_list = e + (ns.e | replace(' ','')).split(',') | unique | list %}
                {# devices #}
                  {%- set ns = namespace(d=d) %}
                  {%- for call in service_calls %}
                    {%- set d2 = [
                                call.get('device_id', []),
                                call.get('data', {}).get('device_id', []),
                                call.get('target', {}).get('device_id', []),
                                call.get('extra', {}).get('device_id', []),
                                call.get('data', {}).get('script_extra', {}).get('device_id', [])
                              ] %}
                    {%- set d2 = ([d2 | select('string') | join(',')] + d | reject('string') | sum(start=[])) | join(',') %}
                    {%- set ns.d = [ns.d, d2 ] | select() | join(',') %}
                  {%- endfor %}
                  {%- set device_list = d + (ns.d | replace(' ', '')).split(',') | select() | unique | list %}
                {# areas #}
                  {%- set ns = namespace(a=a) %}
                  {%- for call in service_calls %}
                    {%- set a2 = [
                                call.get('area_id', []),
                                call.get('data', {}).get('area_id', []),
                                call.get('target', {}).get('area_id', []),
                                call.get('extra', {}).get('area_id', []),
                                call.get('data', {}).get('script_extra', {}).get('area_id', [])
                              ] %}
                    {%- set a = ([a2 | select('string') | join(',')] + a | reject('string') | sum(start=[])) | join(',') %}
                    {%- set ns.a = [ns.a, a2 ] | select() | join(',') %}
                  {%- endfor %}
                  {%- set area_list = a + (ns.a | replace(' ', '')).split(',') | select() | unique | list %}
              {# create entity list based on device/area input #}
                {# determine entities of areas #}
                  {%- set area_list = area_list | map('area_entities') | sum(start=[]) | list %}
                {# determine entities of devices #}
                  {%- set device_list = device_list | map('device_entities') | sum(start=[]) | list %}
              {# create list with all cast and mass entities #}
                {%- set total_list = (area_list + device_list + entity_list) | unique | list %}
                {%- set total_list = total_list | select('in', entities_check) | list %}
            {%- endif %}
            {# replace mass entities with cast entities #}
              {%- if mass_entities and total_list | select('search', '.mass_') | list %}
                {%- set no_mass = total_list | map('replace', '.mass_', '.') | list %}
                {%- set total_list = no_mass | select('in', cast_entities) | unique | list %}
              {%- endif %}
            {# avoid to target both complete speaker groups and single members #}
              {{ total_list }}
              {%- set members = player_data
                                  | selectattr('entity_id', 'in', total_list)
                                  | map(attribute='members')
                                  | sum(start=[])
              %}
              {% set target_list = total_list | reject('in', members) | list %}
      - variables:
          players_to_resume: >
            {%- set target_list = players_to_resume if players_to_resume is defined else target_list %}
            {# determine entities which are playing #}
              {%- set playing = player_data | selectattr('state', 'eq', 'playing') | map(attribute='entity_id') | list %}
            {# add members of playing groups (they are sometimes not shown as playing) #}
              {%- set playing = playing + player_data 
                                          | selectattr('state', 'eq', 'playing')
                                          | selectattr('type', 'eq', 'group')
                                          | map(attribute='members')
                                          | sum(start=[])
              %}
            {# add members of groups in target_list to create checklist of entities #}
              {%- set checklist = target_list + player_data
                                                | selectattr('entity_id', 'in', target_list)
                                                | map(attribute='members')
                                                | sum(start=[])
              %}
            {# check which entities in checklist are playing #}
              {%- set checklist_playing = checklist | select('in', playing) | list %}
            {# check if entities in checklist are part af a group which is playing#}
              {%- set groups_playing = player_data
                                        | selectattr('state', 'eq', 'playing') 
                                        | selectattr('type', 'eq', 'group')
                                        | selectattr('members', 'search', checklist_playing | join('|'))
                                        | map(attribute='entity_id')
                                        | list
            %}
            {# create lists of members of playing groups #}
              {%- set members_reject = player_data
                                        | selectattr('entity_id', 'in', groups_playing)
                                        | map(attribute='members')
                                        | sum(start=[])
              %}
            {# create list of playing members of groups in checlist #}
              {%- set members_playing = player_data
                                        | selectattr('entity_id', 'in', checklist)
                                        | selectattr('state', 'eq', 'playing')
                                        | map(attribute='entity_id')
                                        | list
            %}
            {# combine it all to determine which entities should be resumed #}
              {{ (checklist_playing + groups_playing + members_playing)
                                                  | reject('in', members_reject + resume_active)
                                                  | unique
                                                  | list
              }}
      - alias: "Send log message about wrong wrong primary_spotcast"
        if: "{{ not primary_spotcast_check }}"
        then:
          - service: system_log.write
            data:
              level: "warning"
              logger: "{{ this.entity_id }}"
              message: >
                The primary_spotcast account provided was incorrect or not provided. 
                The script will not use accounts for Spotify resume, and will always use 
                the primary spotcast account.
      - variables:
          target_not_playing: >
            {%-
              set playing = player_data
                | selectattr('state', 'eq', 'playing')
                | map(attribute='entity_id')
                | list
            %}
            {%- set groupmembers = speaker_groups.items()
                                    | selectattr('0', 'in', target_list)
                                    | map(attribute='1')
                                    | sum(start=[]) | unique | list
            %}
            {{ (target_list + groupmembers) | reject('in', speaker_group_list + playing) | unique | list }}
          target_no_volume: >
            {{ player_data
                | selectattr('entity_id', 'in', target_not_playing)
                | selectattr('state', 'eq', 'off')
                | map(attribute='entity_id')
                | list
            }}
      - alias: "Create group with entities for which the script is active"
        service: group.set
        data:
          object_id: resume_script_active_ghresume_{{ context.id | lower }}
          name: "Entities currently active with Google Home Resume script"
          icon: mdi:play-box
          entities: >
            {%- set target = players_to_resume + target_not_playing %}
            {%- set members = speaker_groups.items() | selectattr('0', 'in', target) | map(attribute='1') | sum(start=[]) %}
            {{ target + members }}
      - alias: "Create group for resume_this_action setting"
        if: "{{ iif(resume_this_action is defined and resume_this_action,false,true) }}"
        then:
          - alias: "Create group entities with resume_this_action to false"
            service: group.set
            data:
              object_id: resume_action_false_ghresume_{{ context.id | lower }}
              name: "Entities with actions which should not be resumed"
              icon: mdi:alert-octagon
              entities: >
                {%- set target = players_to_resume + target_not_playing %}
                {%- set members = speaker_groups.items() | selectattr('0', 'in', target) | map(attribute='1') | sum(start=[]) %}
                {{ target + members }}
      - alias: "Turn non playing entities on if needed"
        if: >
          {{ target_no_volume | count > 0 }}
        then:
          - alias: "Turn non playing entities on"
            service: media_player.turn_on
            continue_on_error: true
            target:
              entity_id: "{{ target_no_volume }}"
          - wait_template: >
              {{ expand(target_no_volume) | selectattr('state', 'eq', 'off') | list | count == 0 }}
            timeout: "00:00:03"
      - alias: Add volume for players which were off
        variables:
          player_data: >
            {%- if target_no_volume | count > 0 %}
              {%- set ns = namespace(info=[]) %}
              {%- for entity in player_data %}
                {%- if entity.state == 'off' and entity.entity_id in target_not_playing %}
                  {%- set volume = state_attr(entity.entity_id, 'volume_level') %}
                  {%- set volume = volume if volume | is_number else settings.get('default_volume_level') | default(0.25, true) %}
                  {%- set add_volume = dict(volume_level = volume) %}
                  {%- set ns.info = ns.info + [ dict(entity, **add_volume) ] %}
                {%- else %}
                  {%- set ns.info = ns.info + [ entity ] %}
                {%- endif %}
              {%- endfor %}
              {{ ns.info }}
            {%- else %}
              {{ player_data }}
            {%- endif %}
      - alias: "Interrupt YouTube music if needed"
        if: >
          {{
            player_data
              | rejectattr('data_source', 'in', [ 'automation', 'voice_script' ])
              | selectattr('entity_id', 'in', players_to_resume)
              | selectattr('yt_player', 'defined')
              | list
              | count > 0
          }}
        then:
          - service: ytube_music_player.call_method
            data:
              entity_id: >
                {{
                  player_data
                    | selectattr('entity_id', 'in', players_to_resume)
                    | selectattr('yt_player', 'defined')
                    | map(attribute='yt_player')
                    | list
                }}
              command: interrupt_start
      - alias: "Create Music Assistant snapshots if needed"
        repeat: &mass_snapshot
          for_each: "{{ mass_playing }}"
          sequence:
            - service: mass.queue_command
              target:
                entity_id: "{{ repeat.item }}"
              data:
                command: snapshot_create
      - alias: "Perform service calls defined in action"
        repeat:
          for_each: "{{ service_calls }}"
          sequence:
            - variables:
                service_call: "{{ repeat.item }}"
                target: >
                  {%- set s = service_call.items() | selectattr('0', 'in', ['entity_id', 'area_id', 'device_id']) | list %}
                  {%- set d = service_call.get('data', {}).items() | selectattr('0', 'in', ['entity_id', 'area_id', 'device_id']) | list %}
                  {%- set t = service_call.get('target', {}).items() | selectattr('0', 'in', ['entity_id', 'area_id', 'device_id']) | list %}
                  {{ dict(s, **dict(t, **dict(d))) }}
                extra: >
                  {%- set extra =
                            dict(service_call.get('extra', {}).items()
                                    | rejectattr('0', 'in', ['entity_id', 'area_id', 'device_id', 'script_extra']
                                    | list)
                                  )
                  %}
                  {%- set script_extra =
                            dict(service_call.get('data', {}).get('script_extra', {}).items()
                                    | rejectattr('0', 'in', ['entity_id', 'area_id', 'device_id', 'script_extra']
                                    | list)
                                  )
                  %}
                  {{ dict(extra, **script_extra) }}
                volume_set: "{{ iif(extra.get('volume', '')) }}"
                wait_set: "{{ extra.get('wait', false) }}"
                tts: "{{ service_call.service.split('.')[0] == 'tts' }}"
                target_entities: >
                  {%- set e = target.get('entity_id', []) %}
                  {%- set d = target.get('device_id', []) %}
                  {%- set a = target.get('area_id', []) %}
                  {%- set e = e.replace(' ','').split(',') if e is string else e %}
                  {%- set d = d.replace(' ','').split(',') if d is string else d %}
                  {%- set a = a.replace(' ','').split(',') if a is string else a %}
                  {%- set ee = extra.get('entity_id', []) %}
                  {%- set ed = extra.get('device_id', []) %}
                  {%- set ea = extra.get('area_id', []) %}
                  {%- set e = e + (ee.replace(' ','').split(',') if ee is string else ee) %}
                  {%- set d = d + (ed.replace(' ','').split(',') if ed is string else ed) %}
                  {%- set a = a + (ea.replace(' ','').split(',') if ea is string else ea) %}
                  {# create entity list based on device/area input #}
                    {# determine cast entities of areas #}
                      {%- set ns = namespace(area_cast = []) %}
                      {%- for area in a %}
                        {%- set ns.area_cast = ns.area_cast + area_entities(area) | list %}
                      {%- endfor %}
                      {%- set a = ns.area_cast %}
                    {# determine cast entities of devices #}
                      {%- set ns = namespace(device_cast = []) %}
                      {%- for device in d %}
                        {%- set ns.device_cast = ns.device_cast + device_entities(device) | list %}
                      {%- endfor %}
                      {%- set d = ns.device_cast %}
                  {# create list with all entities #}
                    {{ (a + d + e) | unique | list }}
                media_entities: "{{ expand(target_entities) | selectattr('domain', 'eq', 'media_player') | map(attribute='entity_id') | list }}"
                cast_target: "{{ media_entities | select('in', cast_entities) | list }}"
                screen: >
                  {%- set members = player_data 
                                      | selectattr('entity_id', 'in', cast_target)
                                      | map(attribute='members')
                                      | sum(start=[])
                  %}
                  {{
                    player_data
                      | selectattr('entity_id', 'in', cast_target + members)
                      | selectattr('type', 'eq', 'screen')
                      | list
                      | count > 0
                    and iif(extra)
                    and extra.screen_tts is defined
                    and iif(settings.get('dummy_player'))
                  }}
                data: >
                  {{ dict(service_call.get('data', {}).items() | rejectattr('0', 'in', ['entity_id', 'area_id', 'device_id', 'script_extra']) | list) }}
            - alias: "Stop all targets which are playing"
              service: media_player.media_stop
              target:
                entity_id: "{{ expand(media_entities) | selectattr('state', 'eq', 'playing') | map(attribute='entity_id') | list }}"
            - alias: "Wait until they are all stopped"
              wait_template: "{{ expand(media_entities) | selectattr('state', 'eq', 'playing') | list | count == 0 }}"
            - alias: "Set volume to TTS volume if set"
              choose:
                - conditions: "{{ volume_set }}"
                  sequence:
                    - alias: "Apply TTS volume"
                      service: media_player.volume_set
                      target:
                        entity_id: >
                          {{
                            (
                              media_entities + player_data
                                                  | selectattr('entity_id', 'in', cast_target)
                                                  | map(attribute='members')
                                                  | sum(start=[])
                            ) | reject('in', speaker_group_list) | unique | list
                          }}
                      data:
                        volume_level: "{{ extra.volume }}"
            - alias: "Built in TTS with metadata for screen?"
              choose:
                - conditions: "{{ tts and screen }}"
                  sequence:
                    - alias: "Call TTS for screen script"
                      service: script.turn_on
                      target:
                        entity_id: script.google_home_resume_helper
                      data:
                        variables:
                          dummy_player: "{{ settings.get('dummy_player') }}"
                          target: "{{ target }}"
                          large_text: "{{ extra.screen_tts.get('large_text', '') }}"
                          small_text: "{{ extra.screen_tts.get('small_text', '') }}"
                          picture_url: "{{ extra.screen_tts.get('picture_url', '') }}"
                          action_type: tts
                      continue_on_error: true
            - service: "{{ service_call.service }}"
              target: >
                {%- set mass = target_entities | select('in', mass_playing) | list | count > 0 %}
                {%- if mass %}
                  {%- set ns = namespace(no_mass = []) %}
                  {%- for entity in target_entities %}
                    {%- set e = entity | replace('.mass_', '.') if entity in mass_playing else entity %}
                    {%- set ns.no_mass = ns.no_mass + [ e ] %}
                  {%- endfor %}
                  {%- set target_entities = ns.target_no_mass %}
                  {%- set media_entities = target | select('match', '^media_player') | list %}
                {%- endif %}
                {%- if screen and tts %}
                  {{ dict(entity_id = settings.dummy_player) }}
                {%- elif tts and iif(target.get('area_id', '')) %}
                  {{ dict(entity_id = media_entities) }}
                {%- else %}
                  {{ dict(entity_id = target_entities) if mass else target }}
                {%- endif %}
              data: "{{ data }}"
              continue_on_error: true
            - alias: "Wait until targets are playing and idle again if needed"
              if: "{{ wait_set }}"
              then:
                - wait_for_trigger:
                    - platform: event
                      event_type: state_changed
                      event_data:
                        entity_id: "{{ cast_target[0] }}"
                - wait_template: >
                    {{ expand(cast_target) | rejectattr('state', 'eq', 'playing') | list | count == 0 }}
                - wait_template: >
                    {%- set s = ['idle', 'off', 'unavailable'] %}
                    {{ 
                      expand(cast_target) | selectattr('state', 'in', ['idle', 'off', s]) | list | count
                      == cast_target | count
                    }}
      - alias: "Resume players"
        repeat:
          for_each: >
            {{
              (players_to_resume + target_not_playing)
                | select('in', player_data | map(attribute='entity_id') | list)
                | list
            }}
          sequence:
            - alias: "Variables for specific media_player"
              variables:
                player: "{{ player_data | selectattr('entity_id', 'eq', repeat.item) | join }}"
            - alias: "Start perform resume script"
              service: script.turn_on
              target:
                entity_id: script.google_home_resume_helper
              data:
                variables:
                  start_time: "{{ start_time }}"
                  player: "{{ player }}"
                  member_data: "{{ player_data | selectattr('entity_id', 'in', player.members) | list }}"
                  players_to_resume: "{{ players_to_resume }}"
                  event_script: "{{ event_script }}"
                  resume: "{{ repeat.item in players_to_resume }}"
                  ytube_resume: false
                  action_type: resume
                  resume_delay: >
                    {{ resume_delay if resume_delay is defined and resume_delay else settings.get('default_resume_delay') | default(20, true) }}
      - alias: "Create variable for existing groups"
        variables:
          groups_to_remove: >
            {%- set groups = integration_entities('group') | select('search', 'ghresume') | list %}
            {{ groups if state_attr(this.entity_id, 'current') == 1 else groups | select('search', context.id | lower) | list }}
      - alias: "Wait until helper scripts are finished"
        wait_template: >
          {{ 
            states.script | selectattr('entity_id', 'search', 'script.google_home_resume')
                          | rejectattr('entity_id', 'eq', this.entity_id)
                          | selectattr('attributes.current', 'defined')
                          | map(attribute='attributes.current')
                          | sum == 0
          }}
      - alias: "Remove groups"
        repeat:
          for_each: "{{ groups_to_remove }}"
          sequence:
            - alias: "Remove group"
              service: group.remove
              data:
                object_id: >
                  {{ states[repeat.item].object_id }}

  # The Google Home Resume Helpers script which actually performs the resume on the speaker
  google_home_resume_helper:
    alias: "00 - Google Home Resume - Helper Script"
    description: Helper script for the Google Home Resume script
    icon: mdi:cast-audio
    mode: parallel
    max: 30
    sequence:
      - alias: Variable for version number
        variables: *version
      - if: "{{ action_type == 'resume' }}"
        then:
          - parallel:
              - sequence:
                  - variables:
                      image: >
                        {{
                          state_attr(player.entity_id, 'media_content_id') is not none
                          and (
                                'jpg' in state_attr(player.entity_id, 'media_content_id') | lower
                                or 'jpeg' in state_attr(player.entity_id, 'media_content_id') | lower
                                or 'png' in state_attr(player.entity_id, 'media_content_id') | lower
                                or 'gif' in state_attr(player.entity_id, 'media_content_id') | lower
                                or 'webp' in state_attr(player.entity_id, 'media_content_id') | lower
                              )
                        }}
                      dashboard_cast: "{{ is_state_attr(player.entity_id, 'app_name', 'Home Assistant Lovelace') }}"
                  - alias: "State changed since script started?"
                    wait_template: >
                      {{
                        event_script
                        or ytube_resume
                        or (
                            (states[player.entity_id].last_changed > as_datetime(start_time))
                            and expand([player.entity_id] + player.members)
                                  | selectattr('state', 'eq', 'playing')
                                  | list | count > 0
                          )
                        or image
                        or dashboard_cast
                      }}
                    timeout: "00:00:30"
                  - variables:
                      state_changed: "{{ wait.completed }}"
                      current_volume: "{{ state_attr(player.entity_id, 'volume_level') | round(2, default=0.0) }}"
                      data_volume: "{{ player.get('volume_level', 0.0) | round(2) }}"
                  - alias: "Add entity to the restore active group"
                    service: group.set
                    data:
                      object_id: resume_active_ghresume_{{ context.id | lower }}
                      name: "Entities which will be resumed by the Google Home Resume script"
                      icon: mdi:autorenew
                      entities: >
                        {%- set g = 'group.resume_active_ghresume_' ~ context.id | lower %}
                        {%- set current = state_attr(g, 'entity_id') %}
                        {%- set current = [] if current == none else current | list %}
                        {{ ( current + [ player.entity_id ] + player.members) | unique | list }}
                  - alias: "Wait until player is idle again, and all other scripts are finished"
                    wait_template: >
                      {%- set current = expand(states.group
                                          | selectattr('entity_id', 'search', 'group.resume_script_target_')
                                          | rejectattr('entity_id', 'search', context)
                                          | map(attribute='entity_id')
                                          | list) | map(attribute='entity_id') | list
                      %}
                      {%- set checklist = [player.entity_id] + player.members %}
                      {{
                        dashboard_cast or
                        expand(checklist) | rejectattr('state', 'in', ['idle', 'off', 'paused']) | list | count == 0
                        and current | select('eq', player.entity_id) | list | count == 0
                      }}
                  - if: "{{ image or dashboard_cast }}"
                    then:
                      - delay: "{{ resume_delay }}"
                  - alias: "Restore volume in case volume has changed"
                    if: "{{ data_volume != current_volume }}"
                    then:
                      - alias: "Restore volume"
                        repeat:
                          for_each: "{{ player.members if player.type == 'group' else [ player.entity_id ] }}"
                          sequence:
                            - alias: "Set volume back to old state"
                              service: media_player.volume_set
                              target:
                                entity_id: "{{ repeat.item }}"
                              data:
                                volume_level: >
                                  {%- if player.type == 'group' %}
                                    {{ member_data | selectattr('entity_id', 'eq', repeat.item) | map(attribute='volume_level') | join }}
                                  {%- else %}
                                    {{ data_volume }}
                                  {%- endif %}
                  - alias: "Google Home with screen back to idle screen"
                    if: "{{ player.type == 'screen' and not resume }}"
                    then:
                      - alias: "Turn Google Home off to return to idle mode (photo display)"
                        service: media_player.turn_off
                        target:
                          entity_id: "{{ player.entity_id }}"
                  - alias: "Resume needed?"
                    if: "{{ ytube_resume or (state_changed and resume) }}"
                    then:
                      - alias: "Set variables"
                        variables:
                          ytube_music: >
                            {{ player.app_name == 'Ytube Music Player' }}
                          spotify: >
                            {{ player.app_name == 'Spotify' }}
                          youtube: >
                            {{ player.app_name in ['YouTube', 'YouTube Music'] }}
                          podcast: >
                            {{ player.app_name == 'Google Podcasts' }}
                          stream: >
                            {{
                              player.media_content_id is defined
                              and player.media_content_id.startswith('http')
                            }}
                          mass: "{{ player.get('mass_playing') | default(false, true) }}"
                      - alias: "Resume playing"
                        choose:
                          - alias: "Music Assistant?"
                            conditions: "{{ mass }}"
                            sequence:
                              - service: mass.queue_command
                                data:
                                  command: snapshot_restore
                                target:
                                  entity_id: "{{ player.mass_sync }}"
                          - alias: "Ytube Music?"
                            conditions: "{{ ytube_music }}"
                            sequence:
                              - variables:
                                  player_ytube: "{{ player.yt_player }}"
                              - service: ytube_music_player.call_method
                                data:
                                  entity_id: "{{ player_ytube }}"
                                  command: interrupt_resume
                              - alias: "Wait until song is playing"
                                wait_template: >
                                  {{ iif(state_attr(player_ytube, '_media_id')) and iif(state_attr(player_ytube, 'media_position')) }}
                                timeout: "00:00:10"
                              - alias: "Go to the right position in the track when resume is performed"
                                if: "{{ wait.completed }}"
                                then: &seek
                                  - alias: "Seek"
                                    service: media_player.media_seek
                                    target:
                                      entity_id: "{{ player.entity_id }}"
                                    data:
                                      seek_position: >
                                        {{ [0, player.media_position - 3] | max }}
                          - alias: "YouTube?"
                            conditions: "{{ player.type == 'screen' and youtube }}"
                            sequence:
                              - alias: "Play video"
                                service: media_player.play_media
                                target:
                                  entity_id: "{{ player.entity_id }}"
                                data:
                                  media_content_type: cast
                                  media_content_id: '{{ dict(app_name="youtube", media_id=player.media_content_id) | to_json }}'
                              - alias: "Wait until video is playing"
                                wait_template: >
                                  {{
                                    is_state_attr(player.entity_id, 'media_content_id', player.media_content_id)
                                    and iif(state_attr(player.entity_id, 'media_position'))
                                  }}
                                timeout: "00:00:10"
                              - alias: "Go to the right position in the track when resume is performed"
                                if: "{{ wait.completed }}"
                                then: *seek
                          - alias: "Spotify?"
                            conditions: "{{ spotify }}"
                            sequence:
                              - variables:
                                  service_data:
                                    entity_id: "{{ player.entity_id }}"
                                    force_playback: true
                                  account_data:
                                    account: "{{ player.spotcast }}"
                              - alias: "Resume spotify"
                                service: spotcast.start
                                data: >
                                  {{ service_data if player.spotcast == 'primary_account' else dict(service_data, **account_data) }}
                              - alias: "Wait until song is playing"
                                wait_template: >
                                  {{ is_state_attr(player.entity_id, 'app_name', 'Spotify') and iif(state_attr(player.entity_id, 'media_position')) }}
                                timeout: "00:00:10"
                              - alias: "Go to the right position in the track when resume is performed"
                                if: "{{ wait.completed }}"
                                then: *seek
                                else:
                                  - alias: "Resume spotify"
                                    service: spotcast.start
                                    data: >
                                      {{ service_data if player.spotcast == 'primary_account' else dict(service_data, **account_data) }}
                                  - alias: "Wait until song is playing"
                                    wait_template: >
                                      {{ is_state_attr(player.entity_id, 'app_name', 'Spotify') and iif(state_attr(player.entity_id, 'media_position')) }}
                                    timeout: "00:00:10"
                                  - alias: "Go to the right position in the track when resume is performed"
                                    if: "{{ wait.completed }}"
                                    then: *seek
                          - alias: "Google Podcast?"
                            conditions: "{{ podcast }}"
                            sequence:
                              - variables:
                                  picture_url: "{{ player.fixed_picture if player.fixed_picture is defined else player.entity_picture }}"
                                  metadata:
                                    metadataType: 3
                                    title: "{{ player.media_title }}"
                                    artist: "{{ player.media_artist }}"
                                  picture:
                                    images:
                                      - url: "{{ picture_url }}"
                              - alias: "Resume stream"
                                service: media_player.play_media
                                target:
                                  entity_id: "{{ player.entity_id }}"
                                data:
                                  media_content_id: "{{ player.media_content_id }}"
                                  media_content_type: "{{ player.media_content_type }}"
                                  extra:
                                    metadata: >
                                      {{ metadata if picture_url == 'no pic' else dict(metadata, **picture) }}
                              - alias: "Wait until media_content_id is available"
                                wait_template: "{{ is_state_attr(player.entity_id, 'media_content_id', player.media_content_id) }}"
                                timeout: "00:00:10"
                              - alias: "Go to the right position in the track when resume is performed"
                                if: "{{ wait.completed }}"
                                then: *seek
                          - alias: "Stream?"
                            conditions: "{{ stream }}"
                            sequence:
                              - variables:
                                  picture_url: "{{ player.entity_picture }}"
                                  metadata:
                                    metadataType: 3
                                    title: "{{ player.media_title }}"
                                    artist: "{{ player.media_artist }}"
                                  picture:
                                    images:
                                      - url: "{{ picture_url }}"
                              - alias: "Resume stream"
                                service: media_player.play_media
                                target:
                                  entity_id: "{{ player.entity_id }}"
                                data:
                                  media_content_id: "{{ player.media_content_id }}"
                                  media_content_type: "{{ player.media_content_type }}"
                                  extra:
                                    metadata: >
                                      {{ metadata if picture_url == 'no pic' else dict(metadata, **picture) }}
                              - alias: "Wait until media_content_id is available"
                                wait_template: "{{ is_state_attr(player.entity_id, 'media_content_id', player.media_content_id) }}"
                                timeout: "00:00:10"
                              - alias: "Play the media to avoid long delays"
                                if: "{{ wait.completed }}"
                                then:
                                  - alias: "Play (avoids long delay)"
                                    service: media_player.media_play
                                    target:
                                      entity_id: "{{ player.entity_id }}"
                  - alias: "Check if resume_action_false group exists"
                    if: >
                      {{ integration_entities('group') | select('search', 'resume_action_false_ghresume_' ~ context.id | lower) | list | count > 0 }}
                    then:
                      - alias: "Remove entity + members from group"
                        service: group.set
                        data:
                          object_id: resume_action_false_ghresume_{{ context.id | lower }}
                          name: "Entities with actions which should not be resumed"
                          icon: mdi:alert-octagon
                          entities: >
                            {%- set current = state_attr('group.resume_action_false_ghresume' ~ context.id | lower, 'entity_id') %}
                            {{ iif(current == none, [], current) | reject('in', [player.entity_id] + player.members) | list }}
                  - alias: "Remove entity + members from group"
                    service: group.set
                    data:
                      object_id: resume_active_ghresume_{{ context.id | lower }}
                      name: "Entities which will be resumed by the Google Home Resume script"
                      icon: mdi:autorenew
                      entities: >
                        {%- set g = 'group.resume_active_ghresume_' ~ context.id | lower %}
                        {%- set current = state_attr(g, 'entity_id') %}
                        {{ iif(current == none, [], current) | reject('in', [player.entity_id] + player.members) | list }}
                  - alias: "Remove entity + members from group"
                    service: group.set
                    data:
                      object_id: resume_script_active_ghresume_{{ context.id | lower }}
                      name: "Entities currently active with Google Home Resume script"
                      icon: mdi:play-box
                      entities: >
                        {%- set g = 'group.resume_script_active_ghresume_' ~ context.id | lower %}
                        {%- set current = state_attr(g, 'entity_id') %}
                        {{ iif(current == none, [], current) | reject('in', [player.entity_id] + player.members) | list }}
                  - alias: "Send event that script is finished"
                    event: script_finished_{{ context.id | lower }}
          - if: "{{ max_runtime is defined and max_runtime }}"
            then:
              - alias: "Wait for script to finish"
                wait_for_trigger:
                  - platform: event
                    event_type: script_finished_{{ context.id | lower }}
                timeout: "{{ max_runtime }}"
              - if: "{{ wait.trigger is none }}"
                then:
                  - stop: "Maximum runtime Google Home Resume script reached"
        else:
          - alias: "Wait for TTS to be sent to dummy player"
            wait_for_trigger:
              - platform: event
                event_type: call_service
                event_data:
                  domain: media_player
                  service: play_media
                  service_data:
                    media_content_type: music
                    entity_id: "{{ [ dummy_player ] }}"
          - alias: "Send TTS message with picture"
            service: media_player.play_media
            target: "{{ target }}"
            data:
              media_content_id: "{{ wait.trigger.event.data.service_data.media_content_id }}"
              media_content_type: "music"
              announce: true
              extra:
                metadata:
                  metadataType: 3
                  title: "{{ large_text }}"
                  artist: "{{ small_text }}"
                  images:
                    - url: "{{ picture_url }}"

  # The Google Home Voice script to send an action to a Google Home on which you just asked a question
  # for more details: https://community.home-assistant.io/t/script-to-send-tts-to-the-right-google-home-based-on-voice-commands/346885
  google_home_voice:
    alias: "00 - Google Home Voice"
    icon: mdi:cast-audio
    mode: single
    max_exceeded: silent
    variables: *voice_settings
    sequence:
      - alias: "Copy settings"
        variables:
          settings: *settings
      - alias: "Variable for version number"
        variables: *version
      - alias: "Are there Spotify entities?"
        if: "{{ integration_entities('spotify') | count > 0 }}"
        then:
          - alias: "Update Spotify entities"
            service: homeassistant.update_entity
            target:
              entity_id: "{{ integration_entities('spotify') }}"
      - alias: "Set variables for service calls"
        variables: *service_vars
      - alias: "Set settings and data source"
        variables:
          data_source: voice_script
      - alias: "Set generic variables used by all scripts"
        variables: *generic_vars
      - alias: "Store data cast entities"
        variables:
          player_data: *player_data
      - alias: "Create snapshot of active Music Assistant entities"
        repeat: *mass_snapshot
      - alias: "Interrupt YouTube music if needed"
        if: >
          {{
            player_data
              | selectattr('yt_player', 'defined')
              | list
              | count > 0
          }}
        then:
          - service: ytube_music_player.call_method
            data:
              entity_id: >
                {{
                  player_data
                    | selectattr('yt_player', 'defined')
                    | map(attribute='yt_player')
                    | list
                }}
              command: interrupt_start
      - alias: "Wait until white noise started"
        wait_template: >
          {{ 
            expand(states.media_player)
              | selectattr('attributes.media_title', 'eq', check_for_title)
              | map(attribute='entity_id')
              | list
              | count > 0
          }}
        timeout: "00:00:30"
        continue_on_timeout: false
      - alias: "Determine target for service calls"
        variables:
          target: >
            {{
              expand(integration_entities('cast'))
                | selectattr('attributes.media_title', 'eq', check_for_title)
                | map(attribute='entity_id')
                | first
            }}
          target_list: >
            {%- if target_conversion is defined and target_conversion %}
              {%- set new = target_conversion.get(target, target) %}
              {{ new.replace(' ', '').split(',') if new is string else new }}
            {%- else %}
              {{ [ target ] }}
            {%- endif %}
      - alias: "Stop ambient sound"
        service: media_player.media_stop
        target:
          entity_id: "{{ target }}"
      - alias: "Wrong actions provided"
        choose:
          - conditions: "{{ service_calls | count == 0 }}"
            sequence:
              - stop: "There were no service calls defined, no actions are performed. The script script has been aborted."
                error: true
          - conditions: "{{ no_service_count > 0 }}"
            sequence:
              - service: system_log.write
                data:
                  level: "warning"
                  logger: "{{ this.entity_id }}"
                  message: >
                    {{ no_service_count }} out of {{ service_calls | count }} actions were not performed because they are not service calls.
      - alias: "Wait until plaer is idle"
        wait_template: "{{ is_state(target, 'idle') }}"
      - alias: "Use resume script or perform actions"
        if: "{{ use_resume if use_resume is defined else true }}"
        then:
          - alias: "Send actions using Google Home Resume script"
            service: script.turn_on
            target:
              entity_id: script.google_home_resume
            data:
              variables:
                target_list: "{{ target_list }}"
                player_data: "{{ player_data }}"
                cast_mass_playing: "{{ cast_mass_playing }}"
                action: >
                  {%- set ns = namespace(action=[]) %}
                  {%- for item in service_calls %}
                    {%- set data = item.get('data', {}) %}
                    {%- set extra = item.get('extra', {}) %}
                    {%- set service = item.service %}
                    {%- if target_variable is defined and target_variable %}
                      {%- if service == 'script.turn_on' %}
                        {%- set add = {'voice_target': target_list[0]} %}
                        {%- set var = dict(variables = dict(data.get('variables', {}), **add)) %}
                        {%- set data = dict(data, **var) %}
                      {%- elif service.split('.')[0] == 'script' %}
                        {%- set add = { 'voice_target': target_list[0]} %}
                        {%- set data = dict(data, **add) %}
                      {%- endif %}
                      {%- set add = {'entity_id': target_list[0]} %}
                      {%- set extra = dict(extra, **add) %}
                    {%- endif %}
                    {%- set ns.action = ns.action + [
                                                      dict(
                                                        service = service,
                                                        target = item.get('target', { 'entity_id' : target_list}),
                                                        data = data,
                                                        extra = extra
                                                        )
                                                    ]
                    %}
                  {%- endfor %}
                  {{ ns.action }}
          - alias: "Resume ytube players which are not a target"
            if: >
              {{
                player_data
                  | selectattr('media_content_id', 'eq', 'ytube_music')
                  | rejectattr('entity_id', 'in', target_list)
                  | list
                  | count > 0
              }}
            then:
              - variables:
                  ytube_resume: >
                    {{ player_data
                                | selectattr('media_content_id', 'eq', 'ytube_music')
                                | rejectattr('entity_id', 'in', target_list)
                                | map(attribute='entity_id')
                                | list
                    }}
              - repeat:
                  for_each: "{{ ytube_resume }}"
                  sequence:
                    - alias: "Variables for specific media_player"
                      variables:
                        player: "{{ player_data | selectattr('entity_id', 'eq', repeat.item) | join }}"
                    - service: script.turn_on
                      target:
                        entity_id: script.google_home_resume_helper
                      data:
                        variables:
                          start_time: "{{ now() }}"
                          player: "{{ player }}"
                          member_data: "{{ player_data | selectattr('entity_id', 'in', player.members) | list }}"
                          players_to_resume: "{{ players_to_resume }}"
                          event_script: "{{ event_script }}"
                          resume: "{{ repeat.item in players_to_resume }}"
                          ytube_resume: true
                          action_type: resume
        else:
          - alias: "Perform service calls defined in action"
            repeat:
              for_each: "{{ service_calls }}"
              sequence:
                - variables:
                    data: >
                      {%- set data = repeat.item.get('data', {}) %}
                      {%- set service = repeat.item.service %}
                      {%- if target_variable is defined and target_variable %}
                        {%- if service == 'script.turn_on' %}
                          {%- set add = {'voice_target': target_list[0]} %}
                          {%- set var = dict(variables = dict(data.get('variables', {}), **add)) %}
                          {{ dict(data, **var) }}
                        {%- elif service.split('.')[0] == 'script' %}
                          {%- set add = { 'voice_target': target_list[0]} %}
                          {{ dict(data, **add) }}
                        {%- else %}
                          {{ data }}
                        {%- endif %}
                      {%- else %}
                        {{ data }}
                      {%- endif %}
                - service: "{{ repeat.item.service }}"
                  target: "{{ repeat.item.get('target', { 'entity_id': target_list}) }}"
                  data: "{{ data }}"
      - alias: "Volume defined"
        if: "{{ volume is defined and iif(volume) }}"
        then:
          - alias: "Apply volume"
            service: media_player.volume_set
            target:
              entity_id: "{{ target_list }}"
            data:
              volume_level: >
                {{ [1, volume if volume <= 1 else volume / 100] | min }}

  # Script and template binary sensor to resume streams on Google Home speakes after something happened inside your home.
  # Example: you can stop the media_players when you leave home, and resume them when you return
  # for more details: https://github.com/TheFes/HA-configuration/blob/main/include/integrations/packages/google_cast/docs/google_home_event.md
  google_home_event:
    alias: "00 - Google Home Event"
    description: Script for resuming Google Home speakers
    icon: mdi:cast-audio
    mode: parallel
    fields:
      resume_id:
        description: "ID to match the storing and resuming (default is 'not provided')"
        required: false
        selector:
          text:
      resume:
        description: "True for resuming the states, false for storing the states (default is false)"
        required: false
        selector:
          boolean:
      target:
        description: "Enter the targets cast devices to be resumed afterwards (default is all)"
        required: false
        selector:
          target:
            entity:
              integration: cast
              domain: media_player
            device:
              integration: cast
      ignore:
        description: "Enter the cast devices to be ignored during store and resume (default is none)"
        required: false
        selector:
          target:
            entity:
              integration: cast
              domain: media_player
            device:
              integration: cast
      also_stop:
        description: "Enter the media_players which should also be turned off after storing the data (default is none)"
        required: false
        selector:
          target:
            entity:
              domain: media_player
      resume_volume:
        description: "Volume to be used then resuming the speaker, should be set while storing the data. Eiter use a number between 0 and 1 or 1 and 100 (%)"
        required: false
        selector:
          number:
            min: 0
            max: 100
      remove_data:
        description: "Set to true if you want to remove all stored data (default is false)"
        required: false
        selector:
          boolean:
    sequence:
      - variables:
          version: *ver
      - variables:
          resume_id: "{{ resume_id if (resume_id is defined and resume_id) else 'not provided' }}"
          resume_volume: >
            {%- if resume_volume is defined and iif(resume_volume) %}
              {{ [1, resume_volume / 100] | min if resume_volume > 1 else resume_volume }}
            {%- endif %}
          ignore_list: >
            {%- set cast_entities = integration_entities('cast') %}
            {%- set ignore = ignore | default({}, true) %}
            {# create lists based on target input #}
              {%- set a = ignore.get('area_id', []) %}
              {%- set d = ignore.get('device_id', []) %}
              {%- set e = ignore.get('entity_id', []) %}
              {%- set a = (a | replace(' ', '')).split(',') if a is string else a %}
              {%- set d = (d | replace(' ', '')).split(',') if d is string else d %}
              {%- set e = ((e | replace(' ', '')).split(',') if e is string else e) | select('in', cast_entities) | list %}
            {# create entity list based on device/area input #}
              {# determine entities of areas #}
                {%- set a = a | map('area_entities') | sum(start=[]) | select('in', cast_entities) | list %}
              {# determine entities of devices #}
                {%- set d = d | map('device_entities') | sum(start=[]) | select('in', cast_entities) | list %}
            {# create list with all cast and mass entities #}
            {{ (a + d + e) | unique | list }}
          target_list: >
            {%- set cast_entities = integration_entities('cast') %}
            {%- set target = target | default({}, true) %}
            {# create lists based on target input #}
              {%- set a = target.get('area_id', []) %}
              {%- set d = target.get('device_id', []) %}
              {%- set e = target.get('entity_id', []) %}
              {%- set a = (a | replace(' ', '')).split(',') if a is string else a %}
              {%- set d = (d | replace(' ', '')).split(',') if d is string else d %}
              {%- set e = ((e | replace(' ', '')).split(',') if e is string else e) | select('in', cast_entities) | list %}
            {# create entity list based on device/area input #}
              {# determine entities of areas #}
                {%- set a = a | map('area_entities') | sum(start=[]) | select('in', cast_entities) | list %}
              {# determine entities of devices #}
                {%- set d = d | map('device_entities') | sum(start=[]) | select('in', cast_entities) | list %}
            {# create list with all cast and mass entities #}
              {%- set target_list = (a + d + e) | unique | list %}
            {{ target_list | default(cast_entities, true) | reject('in', ignore_list) | list }}
          all: "{{ target_list == integration_entities('cast') }}"
      - alias: "Store or resume or remove data"
        choose:
          - conditions: "{{ remove_data if remove_data is defined else false }}"
            sequence:
              - event: store_data
                event_data:
                  resume_data: []
          - conditions: "{{ not resume if resume is defined else true }}"
            sequence:
              - alias: "Are there Spotify entities?"
                if: "{{ integration_entities('spotify') | count > 0 }}"
                then:
                  - alias: "Update Spotify entities"
                    service: homeassistant.update_entity
                    target:
                      entity_id: "{{ integration_entities('spotify') }}"
              - variables:
                  settings: *settings
                  data_source: event_script
              - variables: *generic_vars
              - variables:
                  player_data: *player_data
                  resume_data_new:
                    - resume_id: "{{ resume_id }}"
                      player_data: "{{ player_data }}"
                      cast_mass_playing: "{{ cast_mass_playing }}"
                  resume_data: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event' , 'resume_data') | rejectattr('resume_id', 'eq', resume_id) | list + resume_data_new }}
              - event: store_data
                event_data:
                  resume_data: "{{ resume_data }}"
              - alias: "Interrupt YouTube music if needed"
                if: >
                  {{ player_data
                      | selectattr('yt_player', 'defined')
                      | list
                      | count > 0
                  }}
                then:
                  - service: ytube_music_player.call_method
                    data:
                      entity_id: >
                        {{ player_data
                            | selectattr('yt_player', 'defined')
                            | map(attribute='yt_player')
                            | list
                        }}
                      command: interrupt_start
              - alias: "Create snapshot of active Music Assistant entities"
                repeat: *mass_snapshot
              - variables:
                  also_stop_list: >
                    {# create also_stop lists #}
                    {%- if also_stop is defined %}
                      {# create lists based on target input #}
                        {%- set area_list = also_stop.get('area_id', []) %}
                        {%- set area_list = area_list.replace(' ' , '').split(',') if area_list is string else area_list %}
                        {%- set device_list = also_stop.get('device_id', [])%}
                        {%- set device_list = device_list.replace(' ' , '').split(',') if device_list is string else device_list %}
                        {%- set entity_list = also_stop.get('entity_id', []) %}
                        {%- set entity_list = entity_list.replace(' ' , '').split(',') if entity_list is string else entity_list %}
                      {# determine cast entities of areas #}
                        {%- set ns = namespace(area_cast = []) %}
                        {%- for area in area_list %}
                          {%- set ns.area_cast = ns.area_cast + area_entities(area) %}
                        {%- endfor %}
                        {%- set area_list = ns.area_cast | select('match', '^media_player') | list %}
                      {# determine cast entities of devices #}
                        {%- set ns = namespace(device_cast = []) %}
                        {%- for device in device_list %}
                          {%- set ns.device_cast = ns.device_cast + device_entities(device) %}
                        {%- endfor %}
                        {%- set device_list = ns.device_cast | select('match', '^media_player') | list %}
                    {# create list with all entities #}
                      {{ (area_list + device_list + entity_list) | unique | list }}
                    {%- else %}
                      []
                    {%- endif %}
              - service: media_player.turn_off
                target:
                  entity_id: "{{ (integration_entities('cast') | select('in', target_list) | list + also_stop_list) | unique | list }}"
          - conditions: "{{ resume if resume is defined else false }}"
            sequence:
              - variables:
                  player_data: >
                    {{
                      state_attr('binary_sensor.resume_data_google_home_event', 'resume_data')
                        | selectattr('resume_id', 'eq', resume_id)
                        | map(attribute='player_data')
                        | first
                    }}
                  players_to_resume: >
                    {%- set player_list = player_data
                                          | selectattr('state', 'eq', 'playing')
                                          | map(attribute='entity_id')
                                          | list
                    %}
                    {{ player_list | select('in', target_list) | list }}
                  cast_mass_playing: >
                    {{
                      state_attr('binary_sensor.resume_data_google_home_event', 'resume_data')
                        | selectattr('resume_id', 'eq', resume_id)
                        | map(attribute='cast_mass_playing')
                        | first
                    }}
              - alias: "Anything to resume?"
                if: "{{ players_to_resume | count > 0 }}"
                then:
                  - alias: "Resume players"
                    service: script.turn_on
                    target:
                      entity_id: script.google_home_resume
                    data:
                      variables:
                        player_data: "{{ player_data }}"
                        players_to_resume: "{{ players_to_resume }}"
                        cast_mass_playing: "{{ cast_mass_playing }}"
                        action: []
                        event_script: true
              - variables:
                  resume_data: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event' , 'resume_data') | rejectattr('resume_id', 'eq', resume_id) | list }}
              - event: store_data
                event_data:
                  resume_data: "{{ resume_data }}"

# Template sensor to store the data for the event script
template:
  - trigger:
      - platform: event
        event_type: "store_data"
    binary_sensor:
      - unique_id: 14f08591-c1ba-4364-8335-054eb5d0a822
        name: "Resume Data Google Home Event"
        state: >
          {{ trigger.event.data.resume_data | count > 0 }}
        attributes:
          version: *ver
          resume_data: >
            {{ trigger.event.data.resume_data }}

# Automation for automatic resume after specific service calls
automation:
  - alias: 00 - Google Home Automatic Resume
    id: 417395bc-bd64-40a3-b20a-9062d426a01f
    mode: parallel
    max_exceeded: silent
    trigger:
      - platform: event
        enabled: true
        event_type: call_service
        event_data:
          domain: media_player
          service: play_media
        variables:
          announce_volume: "{{ state_attr('script.google_home_resume', 'settings').get('announce_volume_automation') }}"
        id: play
      - platform: event
        enabled: true
        event_type: call_service
        event_data:
          domain: cast
          service: show_lovelace_view
        id: cast
    variables:
      version: *ver
      settings: *settings
      entities: >
        {%- set e = trigger.event.data.service_data.entity_id %}
        {%- set e = (e | replace(' ', '')).split(',') if e is string else e %}
        {%- set e = expand(e) | map(attribute='entity_id') | list %}
        {%- set speaker_groups = settings.get('speaker_groups') | default({}, true) %}
        {%- set members = speaker_groups.items() | selectattr('0', 'in', e) | map(attribute='1') | sum(start=[]) %}
        {{ e + members }}
    condition:
      - alias: "Check if announce was set on the service call"
        condition: template
        value_template: "{{ trigger.id == 'cast' or trigger.event.data.service_data.get('announce', false) }}"
      - alias: "Check if automation in enabled in script settings"
        condition: template
        value_template: "{{ settings.automation_enabled | default(true) }}"
      - alias: "Check if entity targeted is in cast of mass integration"
        condition: template
        value_template: "{{ entities | select('in', integration_entities('cast') + integration_entities('mass')) | list | count > 0 }}"
      - alias: "Check if dashboard resume is enabled in case of dashboard cast trigger"
        condition: template
        value_template: "{{ trigger.id == 'play' or settings.get('dashboard_cast') | default(true) or settings.get('dashboard_cast') is none }}"
    action:
      - alias: Set variables to be used in the automation
        variables: *generic_vars
      - alias: "Failsafe to remove all groups if no resume scripts are not running"
        if: >
          {{ 
            is_state_attr('script.google_home_resume', 'current', 0)
            and integration_entities('group')
                  | select('search', 'ghresume')
                  | list | count > 0
          }}
        then:
          - alias: "Which groups to remove"
            variables:
              groups_existing: >
                {{ integration_entities('group') | select('search', 'ghresume') | list }}
          - alias: "Loop to remove groups"
            repeat:
              for_each: "{{ groups_existing }}"
              sequence:
                - alias: "Remove one group"
                  service: group.remove
                  data:
                    object_id: "{{ states[repeat.item].object_id }}"
      - alias: "Check if target is already being resumed on in a group which is already being resumed"
        condition: template
        value_template: &group_check >
          {%- set groups = states.group
                    | selectattr('entity_id', 'search', 'resume_script_active_ghresume_')
                    | map(attribute='entity_id')
                    | list
          %}
          {%- set active = expand(groups)
                            | rejectattr('state', 'in', ['unknown', 'unavailable'])
                            | map(attribute='entity_id')
                            | unique
                            | list
          %}
          {%- set members = speaker_groups.items() | selectattr('0', 'in', active) | map(attribute='1') | sum(start=[]) %}
          {%- set active = active + members %}
          {%- set target_members = speaker_groups.items() | selectattr('0', 'in', entities) | map(attribute='1') | sum(start=[]) %}
          {%- set entities = (entities + target_members) | reject('in', speaker_group_list) | unique | list %}
          {{ entities | reject('in', active) | list | count > 0 }}
      - alias: Are there Spotify entities?
        if: "{{ integration_entities('spotify') | count > 0 }}"
        then:
          - alias: Update Spotify entities
            service: homeassistant.update_entity
            target:
              entity_id: "{{ integration_entities('spotify') }}"
      - alias: Set data_source and determine target list
        variables:
          data_source: automation
          target_list: >
            {{
              (integration_entities('cast') + integration_entities('mass'))
                | select('in', entities)
                | list
            }}
      - variables:
          player_data: *player_data
      - alias: Create snapshot of active Music Assistant entities
        repeat: *mass_snapshot
      - alias: "Interrupt YouTube music if needed"
        if: >
          {{ player_data | selectattr('entity_id', 'in', target_list) | selectattr('yt_player', 'defined') | list | count > 0 }}
        then:
          - service: ytube_music_player.call_method
            data:
              entity_id: >
                {{ player_data | selectattr('entity_id', 'in', target_list) | selectattr('yt_player', 'defined') | map(attribute='yt_player') | list }}
              command: interrupt_start
      - if: "{{ trigger.id == 'play' and announce_volume is defined and iif(announce_volume) }}"
        then:
          - wait_template: "{{ is_state(entities|first, 'idle') }}"
          - alias: Set volume for announcement
            service: media_player.volume_set
            target:
              entity_id: "{{ entities }}"
            data:
              volume_level: "{{ announce_volume }}"
      - alias: "Short delay"
        delay: 0.5
      - alias: "Check again if target is already being resumed"
        condition: template
        value_template: *group_check
      - alias: Send actions using Google Home Resume script
        service: script.turn_on
        target:
          entity_id: script.google_home_resume
        data:
          variables:
            start_time: "{{ start_time }}"
            automation: true
            target_list: "{{ target_list }}"
            player_data: "{{ player_data }}"
            cast_mass_playing: "{{ cast_mass_playing }}"
