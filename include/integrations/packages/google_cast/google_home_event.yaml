# Script and template binary sensor to resume streams on Google Home speakes after something happened inside your home.
# Example: you can stop the media_players when you leave home, and resume them when you return
# for more details: https://github.com/TheFes/HA-configuration/blob/main/include/script/00_general/google_cast/docs/google_home_event.md
#

script:
  google_home_event:
    alias: "00 - Google Home Event"
    description: Script for resuming Google Home speakers
    icon: mdi:cast-audio
    mode: parallel
    fields:
      resume_id:
        description: "ID to match the storing and resuming (default is 'not provided')"
        required: false
        selector:
          text:
      resume:
        description: "True for resuming the states, false for storing the states (default is false)"
        required: false
        selector:
          boolean:
      target:
        description: "Enter the targets cast devices to be resumed afterwards (default is all)"
        required: false
        selector:
          target:
            entity:
              integration: cast
              domain: media_player
            device:
              integration: cast
      ignore:
        description: "Enter the cast devices to be ignored during store and resume (default is none)"
        required: false
        selector:
          target:
            entity:
              integration: cast
              domain: media_player
            device:
              integration: cast
      also_stop:
        description: "Enter the media_players which should also be turned off after storing the data (default is none)"
        required: false
        selector:
          target:
            entity:
              domain: media_player
      resume_volume:
        description: "Volume to be used then resuming the speaker, should be set while storing the data. Eiter use a number between 0 and 1 or 1 and 100 (%)"
        required: false
        selector:
          number:
            min: 0
            max: 100
      remove_data:
        description: "Set to true if you want to remove all stored data (default is false)"
        required: false
        selector:
          boolean:
    sequence:
      - variables:
          version: &version 2022.11.2
      - variables:
          resume_id: "{{ resume_id if (resume_id is defined and resume_id) else 'not provided' }}"
          resume_volume: >
            {%- if resume_volume is defined and iif(resume_volume) %}
              {{ [1, resume_volume / 100] | min if resume_volume > 1 else resume_volume }}
            {%- endif %}
          ignore_list: >
            {# determine entities of cast integraton #}
              {%- set cast_entities = integration_entities('cast') %}
            {# create target lists #}
            {%- if ignore is defined %}
              {# create lists based on target input #}
                {%- set area_list = ignore.get('area_id', []) %}
                {%- set area_list = area_list.replace(' ' , '').split(',') if area_list is string else area_list %}
                {%- set device_list = ignore.get('device_id', [])%}
                {%- set device_list = device_list.replace(' ' , '').split(',') if device_list is string else device_list %}
                {%- set entity_list = ignore.get('entity_id', []) %}
                {%- set entity_list = entity_list.replace(' ' , '').split(',') if entity_list is string else entity_list %}
              {# determine cast entities of areas #}
                {%- set ns = namespace(area_cast = []) %}
                {%- for area in area_list %}
                  {%- set ns.area_cast = ns.area_cast + area_entities(area) %}
                {%- endfor %}
                {%- set area_cast = ns.area_cast | select('in', cast_entities) | list %}
              {# determine cast entities of devices #}
                {%- set ns = namespace(device_cast = []) %}
                {%- for device in device_list %}
                  {%- set ns.device_cast = ns.device_cast + device_entities(device) %}
                {%- endfor %}
                {%- set device_cast = ns.device_cast | select('in', cast_entities) | list %}
              {# determine cast entities of all entities #}
                {%- set entity_cast = entity_list | select('in', cast_entities) | list %}
            {# create list with all entities #}
              {{ (area_cast + device_cast + entity_cast) | unique | list }}
            {%- else %}
              []
            {%- endif %}
          target_list: >
            {# determine entities of cast integraton #}
              {%- set cast_entities = integration_entities('cast') %}
            {# create target lists #}
            {%- if target is defined %}
              {# create lists based on target input #}
                {%- set area_list = target.get('area_id', []) %}
                {%- set area_list = area_list.replace(' ' , '').split(',') if area_list is string else area_list %}
                {%- set device_list = target.get('device_id', [])%}
                {%- set device_list = device_list.replace(' ' , '').split(',') if device_list is string else device_list %}
                {%- set entity_list = target.get('entity_id', []) %}
                {%- set entity_list = entity_list.replace(' ' , '').split(',') if entity_list is string else entity_list %}
              {# determine cast entities of areas #}
                {%- set ns = namespace(area_cast = []) %}
                {%- for area in area_list %}
                  {%- set ns.area_cast = ns.area_cast + area_entities(area) %}
                {%- endfor %}
                {%- set area_cast = ns.area_cast | select('in', cast_entities) | list %}
              {# determine cast entities of devices #}
                {%- set ns = namespace(device_cast = []) %}
                {%- for device in device_list %}
                  {%- set ns.device_cast = ns.device_cast + device_entities(device) %}
                {%- endfor %}
                {%- set device_cast = ns.device_cast | select('in', cast_entities) | list %}
              {# determine cast entities of all entities #}
                {%- set entity_cast = entity_list | select('in', cast_entities) | list %}
            {# create list with all entities #}
              {% set target_list = (area_cast + device_cast + entity_cast) | unique | list %}
            {%- else %}
              {% set target_list = integration_entities('cast') %}
            {%- endif %}
            {{ target_list | reject('in', ignore_list) | list }}
          all: "{{ target_list == integration_entities('cast') }}"
      - alias: "Store or resume or remove data"
        choose:
          - conditions: "{{ remove_data if remove_data is defined else false }}"
            sequence:
              - event: store_data
                event_data:
                  resume_data: []
          - conditions: "{{ not resume if resume is defined else true }}"
            sequence:
              - alias: "Are there Spotify entities?"
                if: "{{ integration_entities('spotify') | count > 0 }}"
                then:
                  - alias: "Update Spotify entities"
                    service: homeassistant.update_entity
                    target:
                      entity_id: "{{ integration_entities('spotify') }}"
              - variables:
                  settings: "{{ state_attr('script.google_home_resume', 'settings') | to_json }}"
              - variables:
                  data_source: event_script
                  speaker_group_list: "{{ settings.get('speaker_groups') | default({'no group': [ 'no members' ] }, true) }}"
                  speaker_groups: "{{ settings.get('speaker_groups') if speaker_group_list else { 'no group': [ 'no members' ] }  }}"
                  cast_entities: "{{ integration_entities('cast') }}"
                  spotify_entities: "{{ integration_entities('spotify') }}"
                  mass_entities: "{{ integration_entities('mass') | select('match', '^media_player.') | list }}"
                  cast_mass_playing: >
                    {%- if cast_mass_playing is defined %}
                      {{ cast_mass_playing }}
                    {%- else %}
                      {{
                        expand(integration_entities('cast'))
                          | selectattr('attributes.media_title', 'defined')
                          | selectattr('attributes.media_title', 'search', 'Streaming from Music Assistant')
                          | map(attribute='entity_id')
                          | list
                      }}
                    {%- endif %}
                  mass_playing: "{{ (cast_mass_playing | join(',') | replace('.', '.mass_')).split(',') | select() | list }}"
                  primary_spotcast_check: >
                    {% set accounts = (spotify_entities | join(',') | replace('media_player.spotify_', '')).split(',') %}
                    {{ spotify_entities | count <= 1 or settings.get('primary_spotcast') in accounts }}
                  ytube_music_entities: >
                    {{ integration_entities('ytube_music_player') | select('match', '^media_player.') | list }}
              - variables:
                  player_data: >
                    {%- if player_data is undefined %}
                      {# general information for all entities #}
                      {%- set ns = namespace(info=[]) %}
                      {%- for entity in expand(integration_entities('cast')) %}
                          {%- set members = speaker_groups[entity.entity_id]
                                        if speaker_groups is defined
                                          and iif(speaker_groups)
                                          and entity.entity_id in speaker_group_list
                                        else []
                          %}
                          {%- set screen = entity.entity_id in settings.get('players_screen') | default([], true) %}
                          {%- set type = iif(members,'group',iif(screen,'screen','no screen')) %}
                          {%- set general = dict(
                                                  data_source = data_source,
                                                  entity_id = entity.entity_id,
                                                  state = entity.state,
                                                  type = type,
                                                  members = members
                                                  )
                          %}
                          {# add information for Music Assistant #}
                          {%- if mass_entities | count > 0 %}
                            {%- set mass_data = dict(
                                                      mass_playing = entity.entity_id in cast_mass_playing,
                                                      mass_sync = entity.entity_id | replace('.', '.mass_')
                                                    )
                            %}
                            {%- set general = dict(general, **mass_data) %}
                          {%- endif %}
                          {# check if there is a Spotify account playing on this entity #}
                          {%- set list_check = expand([ entity.entity_id ] + members) | map(attribute='name') | list %}
                          {%- set spotify_entity = expand(integration_entities('spotify'))
                                                      | selectattr('state', 'eq', 'playing')
                                                      | selectattr('attributes.source', 'in', list_check)
                                                      | map(attribute='object_id')
                                                      | join
                                                      | replace('spotify_', '')
                          %}
                          {# add volume level #}
                          {%- if not entity.state in ['off', 'unavailable', 'unknown', 'playing'] %}
                            {%- set additional = dict( volume_level = entity.attributes.volume_level | round(2)) %}
                          {# add metadata for playing entities #}
                          {% elif entity.state == 'playing' or spotify_entity %}
                            {%- set additional = dict(
                                                      state = 'playing',
                                                      app_name = entity.attributes.app_name,
                                                      volume_level = entity.attributes.volume_level | round(2),
                                                      media_content_id = (entity.attributes.get('media_content_id', {}) | from_json).get('contentId', 'no media_content')
                                                                          if entity.attributes.get('app_name') == 'Google Podcasts'
                                                                          else entity.attributes.get('media_content_id', 'no media_content'),
                                                      media_position = (as_timestamp(now()) | round(2)
                                                                        - as_timestamp(entity.attributes.get('media_position_updated_at', now())) | round(2)
                                                                        + entity.attributes.get('media_position', 0)) | round(2)
                                                      )
                            %}
                            {# add Spotify account #}
                            {% if entity.attributes.get('app_name') == 'Spotify' %}
                              {%- set spotcast = spotify_entity if spotify_entity
                                                        and settings.primary_spotcast is defined
                                                        and spotify_entity != settings.primary_spotcast
                                                        and integration_entities('spotify') | count > 1
                                                        and primary_spotcast_check
                                                      else 'primary_account' %}
                              {%- set additional = dict(additional,
                                                        **dict(state='playing',
                                                                spotcast = spotcast
                                                              )
                                                      ) 
                              %}
                            {# add information for ytube_music_player integration #}
                            {%- elif entity.entity_id in expand(ytube_music_entities)
                                                          | selectattr('state', 'eq', 'playing')
                                                          | selectattr('attributes.remote_player_id', 'defined')
                                                          | map(attribute='attributes.remote_player_id')
                                                          | list
                            %}
                              {%- set additional = dict(additional,
                                                        **dict(app_name='Ytube Music Player',
                                                                yt_player=expand(ytube_music_entities) | selectattr('attributes.remote_player_id', 'defined') | selectattr('attributes.remote_player_id', 'eq', entity.entity_id) | map(attribute='entity_id') | join,
                                                                media_content_id = 'ytube_music'
                                                              )
                                                      ) 
                              %}
                            {# add infomration for web streams (including TuneIn) #}
                            {% elif entity.attributes.get('app_name') not in ['Spotify', 'YouTube', 'YouTube Music'] %}
                              {%- if entity.attributes.get('media_artist') in (settings.get('radio_data') | default({}, true)).keys() | list %}
                                {% set data = settings.radio_data[entity.attributes.media_artist] %}
                                {% set picture, title = data.get('picture'), data.get('title') %}
                              {% endif %}
                              {%- set additional = dict(additional, **dict(
                                                            media_artist = 'Google Podcasts' if entity.attributes.get('app_name') == 'Google Podcasts'
                                                                            else entity.attributes.get('media_artist', 'no artist'),
                                                            media_title = title if title is defined else entity.attributes.get('media_title', 'no title'),
                                                            media_content_type = '' ~ entity.attributes.get('media_content_type', 'no type'),
                                                            entity_picture = picture if picture is defined else entity.attributes.get('entity_picture', 'no pic')
                                                            ))
                              %}
                            {% endif %}
                          {% endif %}
                        {# cobmine all data #}
                        {%- set ns.info = ns.info + [ dict(general, **additional) if additional is defined else general ] %}
                      {%- endfor %}
                      {{ ns.info }}
                    {%- else %}
                      {{ player_data }}
                    {%- endif %}
                  resume_data_new:
                    - resume_id: "{{ resume_id }}"
                      player_data: "{{ player_data }}"
                      cast_mass_playing: "{{ cast_mass_playing }}"
                  resume_data: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event' , 'resume_data') | rejectattr('resume_id', 'eq', resume_id) | list + resume_data_new }}
              - event: store_data
                event_data:
                  resume_data: "{{ resume_data }}"
              - alias: "Interrupt YouTube music if needed"
                if: >
                  {{ player_data
                      | selectattr('yt_player', 'defined')
                      | list
                      | count > 0
                  }}
                then:
                  - service: ytube_music_player.call_method
                    data:
                      entity_id: >
                        {{ player_data
                            | selectattr('yt_player', 'defined')
                            | map(attribute='yt_player')
                            | list
                        }}
                      command: interrupt_start
              - alias: "Create snapshot of active Music Assistant entities"
                repeat:
                  for_each: "{{ mass_playing }}"
                  sequence:
                    - alias: "Create snapshot"
                      service: mass.queue_command
                      target:
                        entity_id: "{{ repeat.item }}"
                      data:
                        command: snapshot_create
              - variables:
                  also_stop_list: >
                    {# create also_stop lists #}
                    {%- if also_stop is defined %}
                      {# create lists based on target input #}
                        {%- set area_list = also_stop.get('area_id', []) %}
                        {%- set area_list = area_list.replace(' ' , '').split(',') if area_list is string else area_list %}
                        {%- set device_list = also_stop.get('device_id', [])%}
                        {%- set device_list = device_list.replace(' ' , '').split(',') if device_list is string else device_list %}
                        {%- set entity_list = also_stop.get('entity_id', []) %}
                        {%- set entity_list = entity_list.replace(' ' , '').split(',') if entity_list is string else entity_list %}
                      {# determine cast entities of areas #}
                        {%- set ns = namespace(area_cast = []) %}
                        {%- for area in area_list %}
                          {%- set ns.area_cast = ns.area_cast + area_entities(area) %}
                        {%- endfor %}
                        {%- set area_list = ns.area_cast | select('match', '^media_player') | list %}
                      {# determine cast entities of devices #}
                        {%- set ns = namespace(device_cast = []) %}
                        {%- for device in device_list %}
                          {%- set ns.device_cast = ns.device_cast + device_entities(device) %}
                        {%- endfor %}
                        {%- set device_list = ns.device_cast | select('match', '^media_player') | list %}
                    {# create list with all entities #}
                      {{ (area_list + device_list + entity_list) | unique | list }}
                    {%- else %}
                      []
                    {%- endif %}
              - service: media_player.turn_off
                target:
                  entity_id: "{{ (integration_entities('cast') | select('in', target_list) | list + also_stop_list) | unique | list }}"
          - conditions: "{{ resume if resume is defined else false }}"
            sequence:
              - variables:
                  player_data: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event', 'resume_data') | selectattr('resume_id', 'eq', resume_id) | map(attribute='player_data') | first }}
                  players_to_resume: >
                    {% set player_list = player_data
                                          | selectattr('state', 'eq', 'playing')
                                          | map(attribute='entity_id')
                                          | list
                    %}
                    {{ player_list | select('in', target_list) | list}}
                  cast_mass_playing: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event'  , 'resume_data') | selectattr('resume_id', 'eq', resume_id) | map(attribute='cast_mass_playing') | first }}
              - alias: "Anything to resume?"
                if: "{{ players_to_resume | count > 0 }}"
                then:
                  - alias: "Resume players"
                    service: script.turn_on
                    target:
                      entity_id: script.google_home_resume
                    data:
                      variables:
                        player_data: "{{ player_data }}"
                        players_to_resume: "{{ players_to_resume }}"
                        cast_mass_playing: "{{ cast_mass_playing }}"
                        action: []
                        event_script: true
              - variables:
                  resume_data: >
                    {{ state_attr('binary_sensor.resume_data_google_home_event' , 'resume_data') | rejectattr('resume_id', 'eq', resume_id) | list }}
              - event: store_data
                event_data:
                  resume_data: "{{ resume_data }}"

template:
  - trigger:
      - platform: event
        event_type: "store_data"
    binary_sensor:
      - unique_id: 14f08591-c1ba-4364-8335-054eb5d0a822
        name: "Resume Data Google Home Event"
        state: >
          {{ trigger.event.data.resume_data | count > 0 }}
        attributes:
          version: *version
          resume_data: >
            {{ trigger.event.data.resume_data }}
