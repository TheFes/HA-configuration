blueprint:
  name: LLM Helper script for fetching weather forecasts
  description: Creates a script which will allow an LLM to fetch weather forecasts
  domain: script
  input:
    weather_entity:
      name: Weather entity
      description: Select the weather entity to use for the forecast
      selector:
        entity:
          multiple: false
          filter:
            domain: weather
mode: parallel
max_exceeded: silent

description: >
  Gets the weather forecast for either a part of a day, or one or more
  full days. In case the weather for the weekend is requested, this means Saturday
  and Sunday
fields:
  start_of_period:
    selector:
      datetime:
    name: Start of period
    description: Start of the period for which the weather is requested
    required: true
  end_of_period:
    selector:
      datetime:
    name: End of period
    description: End of the period for which the weather is requested
    required: true
sequence:
  - variables:
      weather_entity: !input weather_entity
      start: "{{ (start_of_period | as_datetime | as_local).isoformat() }}"
      end: "{{ (end_of_period | as_datetime | as_local).isoformat() }}"
      full_days: >
        {% set start = start | as_datetime %} {% set end = end | as_datetime %}
        {{
          start.time() == today_at().time()
          and ((end - start).total_seconds() / 3600) | round | int % 24 in [23, 0, 1]
        }}
  - action: weather.get_forecasts
    data:
      type: "{{ 'daily' if full_days else 'hourly' }}"
    target:
      entity_id: !input weather_entity
    response_variable: weather_response
  - variables:
      response:
        averaged_weather_data_for_period: >
          {% set weather_data = weather_response[weather_entity].forecast
              | selectattr('datetime', '>=', start)
              | selectattr('datetime', '<', end)
              | list
          %}
          {% set ns = namespace(combined={}) %}
          {% for item in weather_data[0].keys() | reject('eq', 'datetime')%}
            {% set combine = weather_data | map(attribute=item) | list %}
            {% set combine = combine | statistical_mode if combine[0] is string else combine | average | round %}
            {% set ns.combined = dict(ns.combined, **{item: combine}) %}
          {% endfor %}
          {{ dict(start_of_period=start, end_of_period=end, **ns.combined) }}
  - stop: ""
    response_variable: response
