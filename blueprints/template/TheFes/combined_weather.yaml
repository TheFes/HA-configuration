blueprint:
  name: Create a combined weather entity
  description: '# Creates a template weather which combines all your other weather
    integrations

    ## Trigger settings

    By default there are 3 triggers:

    * 30 seconds after every whole hour, to give all weather integrations some time
    to update.
    
    * Every time Home Assistant starts, to ensure the template weather
    uses up-to-date info
    
    * On the manual even `update_combined_forecast` to give an
    option to manually update

    You can add or remove triggers, or change the existing ones

    ## Input settings

    Here you can add weights to weather entities. In case you have a specific entity
    you trust more than others, you can apply additional weight. All weights need
    to be integers. The input needs to be a list, where each list item is a mapping.
    Weights can be applied for the current weather information (`current`), for for
    the 3 forecast types (`daily`, `twice_daily`, `hourly`). Example: ```yaml weight_input:
    - entity_id: weather.knmi current: 3 daily: 3 hourly: 4 - entity_id: weather.buienradar
    current: 2 daily: 2 ```

    In the input settings you can also provide weather entiteis which should be ignored,
    e.g. when you have integrations configured for another location, e.g. where you
    will going on holiday.

    ## Unit of measurement settings

    Set the unit of measurements according to the source sensors. These are the defaults:
    ```yaml
    
    temperature_unit: "°C"
    
    pressure_unit: "hPa" 
    
    wind_speed_unit: "km/h" 
    
    visibility_unit: "km" 
    
    precipitation_unit: "mm" 
    
    ```

    ## Debug mode

    With debug mode enabled, a summary of the information used will be sent as a persistent
    notification every time the template weather triggers. This is disabled by default.'
  author: TheFes
  source_url: https://github.com/TheFes/HA-configuration/blob/main/blueprints/template/TheFes/combined_weather.yaml
  domain: template
  input:
    trigger_settings:
      name: Trigger settings
      icon: mdi:play
      description: Add or remove triggers
      collapsed: true
      input:
        triggers:
          name: Triggers
          description: Triggers used
          selector:
            trigger: {}
          default:
          - alias: Update combined weather forecast hourly at 30 seconds past the
              hour
            trigger: time_pattern
            minutes: '0'
            seconds: '30'
          - alias: Update combined weather forecast on Home Assistant startup
            trigger: homeassistant
            event: start
          - alias: Update combined weather forecast on manual trigger event
            trigger: event
            event_type: update_combined_forecast
    input_settings:
      name: Input settings
      icon: mdi:cloud
      description: Settings to add weight or ignore specific entities
      collapsed: true
      input:
        weight_input:
          name: Weight data
          description: Provide weight data so integrations you trust more have a bigger
            impact
          selector:
            object:
              label_field: weight
              multiple: true
              fields:
                entity_id:
                  label: Weather entity
                  selector:
                    entity:
                      filter:
                        domain: weather
                current:
                  label: Current weather weight
                  selector:
                    number:
                      min: 0
                      max: 5
                      step: 1
                      mode: slider
                hourly:
                  label: Hourly forecast weight
                  selector:
                    number:
                      min: 0
                      max: 5
                      step: 1
                      mode: slider
                twice_daily:
                  label: Twice daily forecast weight
                  selector:
                    number:
                      min: 0
                      max: 5
                      step: 1
                      mode: slider
                daily:
                  label: Daily forecast weight
                  selector:
                    number:
                      min: 0
                      max: 5
                      step: 1
                      mode: slider
          default: []
        ignore_entities:
          name: Ignore entities
          description: Weather entities which should not be taken into account, e.g.
            because they are based on another location
          selector:
            entity:
              filter:
              - domain:
                - weather
              multiple: false
              reorder: false
          default: []
    unit_settings:
      name: Unit of measurement settings
      icon: mdi:eye
      description: Settings of the unit of measurements for the weather entity, make
        sure they match the source entities
      collapsed: true
      input:
        temperature_unit:
          name: Temperature
          description: The unit of meausurement used for temperature
          selector:
            text: {}
          default: °C
        pressure_unit:
          name: Pressure
          description: The unit of meausurement used for pressure
          selector:
            text: {}
          default: hPa
        wind_speed_unit:
          name: Wind speed
          description: The unit of meausurement used for wind speed
          selector:
            text: {}
          default: km/h
        visibility_unit:
          name: Wind speed
          description: The unit of meausurement used for wind visibility
          selector:
            text: {}
          default: km
        precipitation_unit:
          name: Wind speed
          description: The unit of meausurement used for precipitation
          selector:
            text: {}
          default: mm
    debug_mode:
      name: Debug mode
      icon: mdi:bug
      description: Enable or disable debug mode
      collapsed: true
      input:
        debug:
          name: Enable debug mode
          description: With debug mode enabled a persistent notification will be sent
            on every update of the weather entity. The notification will contain information
            on the forecast list and the entities used.
          selector:
            boolean: {}
          default: false
triggers: !input triggers
actions:
- alias: Define weights for different weather integrations
  variables:
    debug: !input debug
    weight: !input weight_input
- alias: Set right forecast type
  variables:
    type: hourly
    supported:
    - 2
    - 3
    - 6
    - 7
- alias: Get the forecast data from the entities
  sequence: &id001
  - alias: Get all entities which support the forecast type
    variables:
      weather_entities: "{{\n  states.weather \n    | selectattr('attributes.supported_features',
        'defined')\n    | selectattr('attributes.supported_features', 'in', supported)\n
        \   | map(attribute='entity_id') \n    | reject('in', integration_entities('template'))\n
        \   | select('has_value')\n    | list\n}}\n"
  - alias: Get forecasts in case there are entities
    if: '{{ weather_entities | count > 0 }}'
    then:
    - alias: Set forecast available flag when entities found
      variables:
        forecast_available: true
    - alias: Get hourly forecast data out of selected entities
      action: weather.get_forecasts
      data:
        type: '{{ type }}'
      target:
        entity_id: '{{ weather_entities }}'
      response_variable: forecast
    else:
    - alias: Set forecast unavailable flag when no entities found
      variables:
        forecast_available: false
- alias: Combine the forecasts in one
  variables:
    hourly_entities: '{{ weather_entities }}'
    hourly: "{# set number of days to use for forecasts #}\n  {% set forecast_days
      = 3 if type == 'hourly' else 10 %}\n{# define valid forecast attributes and
      precision for rounding #}\n  {% set forecast_all = \n    [\n      dict(attr='condition'),\n
      \     dict(attr='wind_bearing', round=2),\n      dict(attr='cloud_coverage',
      round=0),\n      dict(attr='temperature', round=1),\n      dict(attr='wind_speed',
      round=2),\n      dict(attr='precipitation', round=2),\n      dict(attr='precipitation_probability',
      round=0),\n      dict(attr='dew_point', round=1),\n      dict(attr='uv_index',
      round=2),\n      dict(attr='apparent_temperature', round=1),\n      dict(attr='pressure',
      round=2),\n      dict(attr='humidity', round=0)\n    ]\n  %}\n  {% set forecast_daily
      =\n    [\n      dict(attr='templow', round=1),\n      dict(attr='wind_gust_speed',
      round=2)\n    ]\n  %}\n  {% set forecast_twice_daily =\n    [ dict(attr='is_daytime')
      ]\n  %}\n  {% set forecast_attr = forecast_all if type == 'hourly' else forecast_all
      + forecast_daily if type == 'daily' else forecast_all + forecast_twice_daily
      %}\n{# check if forecast is retreived #}\n  {% if forecast_available %}\n  {#
      combine all forecasts in one list #}\n    {% if weight is defined\n        and
      weight is list\n        and weight | count > 0\n        and weight[0] is mapping\n
      \   %}\n      {% set ns = namespace(all=[]) %}\n      {% for k, v in forecast.items()
      %}\n        {% set w = weight \n                    | selectattr('entity_id',
      'eq', k)\n                    | map(attribute=type)\n                    | first\n
      \                   | default(1) %}\n        {% set ns.all = ns.all + v.forecast
      * w %}\n      {% endfor %}\n      {% set all = ns.all %}\n    {% else %}\n      {%
      set all = forecast.values() | map(attribute='forecast') | sum(start=[]) %}\n
      \   {% endif %}\n  {# make sure no old forecasts are included, and only 3 days
      for hourly forecasts, and 10 days for daily #}\n    {% set compare_start = today_at()
      if type == 'daily' else now() - timedelta(hours=1) %}\n    {% set compare_end
      = now() + timedelta(days=forecast_days) %}\n  {# align datetimes so they all
      use local timezone, and the same start time for daily forecasts #}\n    {% set
      ns = namespace(aligned=[], forecast=[]) %}\n    {% for item in all if compare_start
      <= as_datetime(item.datetime) | as_local <= compare_end %}\n      {% set new_dt
      = item.datetime | as_datetime(item.datetime) | as_local %}\n      {% set new_dt
      = new_dt.isoformat() if type in ['hourly', 'twice_daily'] else new_dt.replace(hour=0,
      minute=0).isoformat() %}\n      {% set ns.aligned = ns.aligned + [dict(item,
      datetime=new_dt)] %}\n    {% endfor %}\n  {# set list of unique datetime #}\n
      \   {% set dt_list = ns.aligned | map(attribute='datetime') | unique | sort
      | list %}\n  {# create forecast list item for each datetime #}\n    {% for dt
      in dt_list %}\n      {% set forecasts = ns.aligned | selectattr('datetime',
      'eq', dt) | list %}\n      {% set dt_ns = namespace(keys=[], forecast=dict(datetime=dt))
      %}\n      {# find forecast available forecast items #}\n        {% for item
      in forecasts %}\n          {% set dt_ns.keys = dt_ns.keys + item.keys() | list
      %}\n        {% endfor %}\n        {# remove unsupported types for template weather
      #}\n        {% set allowed_keys = forecast_attr | map(attribute='attr') | list
      %}\n        {% set keys_list = dt_ns.keys | unique | select('in', allowed_keys)
      %}\n      {# find value for each forecast item #}\n        {% for key in keys_list
      %}\n          {% set key_items = forecasts | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n          {# find most frequent item for condition #}\n            {%
      if key == 'condition' %}\n              {% if 'clear-night' in key_items %}\n
      \               {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n              {% endif %}\n              {% set add_dict = dict(condition=statistical_mode(key_items,
      none)) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict)
      %}\n            {% elif key == 'is_daytime' %}\n              {% set add_dict
      = dict(is_daytime=key_items[0]) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast,
      **add_dict) %}                          \n          {# find median for other
      (numeric) forecast types #}\n            {% else %}\n              {# filter
      out non numeric values #}\n                {% set values = key_items  | map('replace',
      none, 0) | select('is_number') | map('float') | list | sort %}\n                {%
      if values | count > 0 %}\n                  {# add forecast item to forecast
      #}\n                    {% set round = forecast_attr | selectattr('attr', 'eq',
      key) | map(attribute='round') | list | first %}\n                    {% set
      add_dict = {key: median(values)|round(round)} %}\n                    {% set
      dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %} \n                {% endif
      %}\n            {% endif %}\n        {% endfor %}\n      {# combine forecast
      for each datetime in one list #}\n        {% set ns.forecast = ns.forecast +
      [dt_ns.forecast] %}\n    {% endfor %}\n  {# output the forecast #}\n    {{ ns.forecast
      }}\n{# create twice daily forecast based on hourly forecast if not provided
      normally #} {% elif type == 'twice_daily' and hourly | count > 0 %}\n  {% set
      times = hourly | selectattr('datetime', 'search', 'T09:00|T18:00') | map(attribute='datetime')
      | list %}\n  {% set ns = namespace(forecast=[], item={}) %}\n  {% for t in times
      %}\n    {% set day = t is search 'T09:00' %}\n    {% set dates = hourly | map(attribute='datetime')
      | list %}\n    {% set index = dates.index(t) %}\n    {% set data = hourly[index:index+(9
      if day else 13)] %}\n    {% set key_list = data[0].keys() | list %}\n    {%
      set ns.item = {'datetime': t, 'is_daytime': day} %}\n    {% for key in key_list
      %}\n      {% set key_items = data | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n      {% if key_items[0] is string %}\n        {% if not day %}\n
      \         {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n        {% endif %}\n        {% set ns.item = dict(ns.item, **{key:
      key_items | statistical_mode}) %}\n      {% elif key == 'temperature' %}\n        {%
      set ns.item = dict(ns.item, **{key: key_items | max, 'templow': key_items |
      min}) %}\n      {% elif key_items[0] | is_number %}\n        {% set r = forecast_attr
      | selectattr('attr', 'eq', key) | map(attribute='round') | first | default(1)
      %}\n        {% set ns.item = dict(ns.item, **{key: key_items | average | round(r)})
      %}\n      {% endif %}\n    {% endfor %}\n    {% set ns.forecast = ns.forecast
      + [ns.item] %}\n  {% endfor %}\n  {{ ns.forecast }}\n{% else %}\n  []\n{% endif
      %}\n"
- alias: Set right forecast type
  variables:
    type: daily
    supported:
    - 1
    - 3
    - 5
    - 7
- alias: Get the forecast data from the entities
  sequence: *id001
- alias: Combine the forecasts in one
  variables:
    daily_entities: '{{ weather_entities }}'
    daily: "{# set number of days to use for forecasts #}\n  {% set forecast_days
      = 3 if type == 'hourly' else 10 %}\n{# define valid forecast attributes and
      precision for rounding #}\n  {% set forecast_all = \n    [\n      dict(attr='condition'),\n
      \     dict(attr='wind_bearing', round=2),\n      dict(attr='cloud_coverage',
      round=0),\n      dict(attr='temperature', round=1),\n      dict(attr='wind_speed',
      round=2),\n      dict(attr='precipitation', round=2),\n      dict(attr='precipitation_probability',
      round=0),\n      dict(attr='dew_point', round=1),\n      dict(attr='uv_index',
      round=2),\n      dict(attr='apparent_temperature', round=1),\n      dict(attr='pressure',
      round=2),\n      dict(attr='humidity', round=0)\n    ]\n  %}\n  {% set forecast_daily
      =\n    [\n      dict(attr='templow', round=1),\n      dict(attr='wind_gust_speed',
      round=2)\n    ]\n  %}\n  {% set forecast_twice_daily =\n    [ dict(attr='is_daytime')
      ]\n  %}\n  {% set forecast_attr = forecast_all if type == 'hourly' else forecast_all
      + forecast_daily if type == 'daily' else forecast_all + forecast_twice_daily
      %}\n{# check if forecast is retreived #}\n  {% if forecast_available %}\n  {#
      combine all forecasts in one list #}\n    {% if weight is defined\n        and
      weight is list\n        and weight | count > 0\n        and weight[0] is mapping\n
      \   %}\n      {% set ns = namespace(all=[]) %}\n      {% for k, v in forecast.items()
      %}\n        {% set w = weight \n                    | selectattr('entity_id',
      'eq', k)\n                    | map(attribute=type)\n                    | first\n
      \                   | default(1) %}\n        {% set ns.all = ns.all + v.forecast
      * w %}\n      {% endfor %}\n      {% set all = ns.all %}\n    {% else %}\n      {%
      set all = forecast.values() | map(attribute='forecast') | sum(start=[]) %}\n
      \   {% endif %}\n  {# make sure no old forecasts are included, and only 3 days
      for hourly forecasts, and 10 days for daily #}\n    {% set compare_start = today_at()
      if type == 'daily' else now() - timedelta(hours=1) %}\n    {% set compare_end
      = now() + timedelta(days=forecast_days) %}\n  {# align datetimes so they all
      use local timezone, and the same start time for daily forecasts #}\n    {% set
      ns = namespace(aligned=[], forecast=[]) %}\n    {% for item in all if compare_start
      <= as_datetime(item.datetime) | as_local <= compare_end %}\n      {% set new_dt
      = item.datetime | as_datetime(item.datetime) | as_local %}\n      {% set new_dt
      = new_dt.isoformat() if type in ['hourly', 'twice_daily'] else new_dt.replace(hour=0,
      minute=0).isoformat() %}\n      {% set ns.aligned = ns.aligned + [dict(item,
      datetime=new_dt)] %}\n    {% endfor %}\n  {# set list of unique datetime #}\n
      \   {% set dt_list = ns.aligned | map(attribute='datetime') | unique | sort
      | list %}\n  {# create forecast list item for each datetime #}\n    {% for dt
      in dt_list %}\n      {% set forecasts = ns.aligned | selectattr('datetime',
      'eq', dt) | list %}\n      {% set dt_ns = namespace(keys=[], forecast=dict(datetime=dt))
      %}\n      {# find forecast available forecast items #}\n        {% for item
      in forecasts %}\n          {% set dt_ns.keys = dt_ns.keys + item.keys() | list
      %}\n        {% endfor %}\n        {# remove unsupported types for template weather
      #}\n        {% set allowed_keys = forecast_attr | map(attribute='attr') | list
      %}\n        {% set keys_list = dt_ns.keys | unique | select('in', allowed_keys)
      %}\n      {# find value for each forecast item #}\n        {% for key in keys_list
      %}\n          {% set key_items = forecasts | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n          {# find most frequent item for condition #}\n            {%
      if key == 'condition' %}\n              {% if 'clear-night' in key_items %}\n
      \               {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n              {% endif %}\n              {% set add_dict = dict(condition=statistical_mode(key_items,
      none)) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict)
      %}\n            {% elif key == 'is_daytime' %}\n              {% set add_dict
      = dict(is_daytime=key_items[0]) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast,
      **add_dict) %}                          \n          {# find median for other
      (numeric) forecast types #}\n            {% else %}\n              {# filter
      out non numeric values #}\n                {% set values = key_items  | map('replace',
      none, 0) | select('is_number') | map('float') | list | sort %}\n                {%
      if values | count > 0 %}\n                  {# add forecast item to forecast
      #}\n                    {% set round = forecast_attr | selectattr('attr', 'eq',
      key) | map(attribute='round') | list | first %}\n                    {% set
      add_dict = {key: median(values)|round(round)} %}\n                    {% set
      dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %} \n                {% endif
      %}\n            {% endif %}\n        {% endfor %}\n      {# combine forecast
      for each datetime in one list #}\n        {% set ns.forecast = ns.forecast +
      [dt_ns.forecast] %}\n    {% endfor %}\n  {# output the forecast #}\n    {{ ns.forecast
      }}\n{# create twice daily forecast based on hourly forecast if not provided
      normally #} {% elif type == 'twice_daily' and hourly | count > 0 %}\n  {% set
      times = hourly | selectattr('datetime', 'search', 'T09:00|T18:00') | map(attribute='datetime')
      | list %}\n  {% set ns = namespace(forecast=[], item={}) %}\n  {% for t in times
      %}\n    {% set day = t is search 'T09:00' %}\n    {% set dates = hourly | map(attribute='datetime')
      | list %}\n    {% set index = dates.index(t) %}\n    {% set data = hourly[index:index+(9
      if day else 13)] %}\n    {% set key_list = data[0].keys() | list %}\n    {%
      set ns.item = {'datetime': t, 'is_daytime': day} %}\n    {% for key in key_list
      %}\n      {% set key_items = data | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n      {% if key_items[0] is string %}\n        {% if not day %}\n
      \         {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n        {% endif %}\n        {% set ns.item = dict(ns.item, **{key:
      key_items | statistical_mode}) %}\n      {% elif key == 'temperature' %}\n        {%
      set ns.item = dict(ns.item, **{key: key_items | max, 'templow': key_items |
      min}) %}\n      {% elif key_items[0] | is_number %}\n        {% set r = forecast_attr
      | selectattr('attr', 'eq', key) | map(attribute='round') | first | default(1)
      %}\n        {% set ns.item = dict(ns.item, **{key: key_items | average | round(r)})
      %}\n      {% endif %}\n    {% endfor %}\n    {% set ns.forecast = ns.forecast
      + [ns.item] %}\n  {% endfor %}\n  {{ ns.forecast }}\n{% else %}\n  []\n{% endif
      %}\n"
- alias: Set right forecast type
  variables:
    type: twice_daily
    supported:
    - 4
    - 5
    - 6
    - 7
- alias: Get the forecast data from the entities
  sequence: *id001
- alias: Combine the forecasts in one
  variables:
    twice_daily_entities: '{{ weather_entities }}'
    twice_daily: "{# set number of days to use for forecasts #}\n  {% set forecast_days
      = 3 if type == 'hourly' else 10 %}\n{# define valid forecast attributes and
      precision for rounding #}\n  {% set forecast_all = \n    [\n      dict(attr='condition'),\n
      \     dict(attr='wind_bearing', round=2),\n      dict(attr='cloud_coverage',
      round=0),\n      dict(attr='temperature', round=1),\n      dict(attr='wind_speed',
      round=2),\n      dict(attr='precipitation', round=2),\n      dict(attr='precipitation_probability',
      round=0),\n      dict(attr='dew_point', round=1),\n      dict(attr='uv_index',
      round=2),\n      dict(attr='apparent_temperature', round=1),\n      dict(attr='pressure',
      round=2),\n      dict(attr='humidity', round=0)\n    ]\n  %}\n  {% set forecast_daily
      =\n    [\n      dict(attr='templow', round=1),\n      dict(attr='wind_gust_speed',
      round=2)\n    ]\n  %}\n  {% set forecast_twice_daily =\n    [ dict(attr='is_daytime')
      ]\n  %}\n  {% set forecast_attr = forecast_all if type == 'hourly' else forecast_all
      + forecast_daily if type == 'daily' else forecast_all + forecast_twice_daily
      %}\n{# check if forecast is retreived #}\n  {% if forecast_available %}\n  {#
      combine all forecasts in one list #}\n    {% if weight is defined\n        and
      weight is list\n        and weight | count > 0\n        and weight[0] is mapping\n
      \   %}\n      {% set ns = namespace(all=[]) %}\n      {% for k, v in forecast.items()
      %}\n        {% set w = weight \n                    | selectattr('entity_id',
      'eq', k)\n                    | map(attribute=type)\n                    | first\n
      \                   | default(1) %}\n        {% set ns.all = ns.all + v.forecast
      * w %}\n      {% endfor %}\n      {% set all = ns.all %}\n    {% else %}\n      {%
      set all = forecast.values() | map(attribute='forecast') | sum(start=[]) %}\n
      \   {% endif %}\n  {# make sure no old forecasts are included, and only 3 days
      for hourly forecasts, and 10 days for daily #}\n    {% set compare_start = today_at()
      if type == 'daily' else now() - timedelta(hours=1) %}\n    {% set compare_end
      = now() + timedelta(days=forecast_days) %}\n  {# align datetimes so they all
      use local timezone, and the same start time for daily forecasts #}\n    {% set
      ns = namespace(aligned=[], forecast=[]) %}\n    {% for item in all if compare_start
      <= as_datetime(item.datetime) | as_local <= compare_end %}\n      {% set new_dt
      = item.datetime | as_datetime(item.datetime) | as_local %}\n      {% set new_dt
      = new_dt.isoformat() if type in ['hourly', 'twice_daily'] else new_dt.replace(hour=0,
      minute=0).isoformat() %}\n      {% set ns.aligned = ns.aligned + [dict(item,
      datetime=new_dt)] %}\n    {% endfor %}\n  {# set list of unique datetime #}\n
      \   {% set dt_list = ns.aligned | map(attribute='datetime') | unique | sort
      | list %}\n  {# create forecast list item for each datetime #}\n    {% for dt
      in dt_list %}\n      {% set forecasts = ns.aligned | selectattr('datetime',
      'eq', dt) | list %}\n      {% set dt_ns = namespace(keys=[], forecast=dict(datetime=dt))
      %}\n      {# find forecast available forecast items #}\n        {% for item
      in forecasts %}\n          {% set dt_ns.keys = dt_ns.keys + item.keys() | list
      %}\n        {% endfor %}\n        {# remove unsupported types for template weather
      #}\n        {% set allowed_keys = forecast_attr | map(attribute='attr') | list
      %}\n        {% set keys_list = dt_ns.keys | unique | select('in', allowed_keys)
      %}\n      {# find value for each forecast item #}\n        {% for key in keys_list
      %}\n          {% set key_items = forecasts | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n          {# find most frequent item for condition #}\n            {%
      if key == 'condition' %}\n              {% if 'clear-night' in key_items %}\n
      \               {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n              {% endif %}\n              {% set add_dict = dict(condition=statistical_mode(key_items,
      none)) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast, **add_dict)
      %}\n            {% elif key == 'is_daytime' %}\n              {% set add_dict
      = dict(is_daytime=key_items[0]) %}\n              {% set dt_ns.forecast = dict(dt_ns.forecast,
      **add_dict) %}                          \n          {# find median for other
      (numeric) forecast types #}\n            {% else %}\n              {# filter
      out non numeric values #}\n                {% set values = key_items  | map('replace',
      none, 0) | select('is_number') | map('float') | list | sort %}\n                {%
      if values | count > 0 %}\n                  {# add forecast item to forecast
      #}\n                    {% set round = forecast_attr | selectattr('attr', 'eq',
      key) | map(attribute='round') | list | first %}\n                    {% set
      add_dict = {key: median(values)|round(round)} %}\n                    {% set
      dt_ns.forecast = dict(dt_ns.forecast, **add_dict) %} \n                {% endif
      %}\n            {% endif %}\n        {% endfor %}\n      {# combine forecast
      for each datetime in one list #}\n        {% set ns.forecast = ns.forecast +
      [dt_ns.forecast] %}\n    {% endfor %}\n  {# output the forecast #}\n    {{ ns.forecast
      }}\n{# create twice daily forecast based on hourly forecast if not provided
      normally #} {% elif type == 'twice_daily' and hourly | count > 0 %}\n  {% set
      times = hourly | selectattr('datetime', 'search', 'T09:00|T18:00') | map(attribute='datetime')
      | list %}\n  {% set ns = namespace(forecast=[], item={}) %}\n  {% for t in times
      %}\n    {% set day = t is search 'T09:00' %}\n    {% set dates = hourly | map(attribute='datetime')
      | list %}\n    {% set index = dates.index(t) %}\n    {% set data = hourly[index:index+(9
      if day else 13)] %}\n    {% set key_list = data[0].keys() | list %}\n    {%
      set ns.item = {'datetime': t, 'is_daytime': day} %}\n    {% for key in key_list
      %}\n      {% set key_items = data | selectattr(key, 'defined') | map(attribute=key)
      | list %}\n      {% if key_items[0] is string %}\n        {% if not day %}\n
      \         {% set key_items = key_items | map('replace', 'sunny', 'clear-night')
      | list %}\n        {% endif %}\n        {% set ns.item = dict(ns.item, **{key:
      key_items | statistical_mode}) %}\n      {% elif key == 'temperature' %}\n        {%
      set ns.item = dict(ns.item, **{key: key_items | max, 'templow': key_items |
      min}) %}\n      {% elif key_items[0] | is_number %}\n        {% set r = forecast_attr
      | selectattr('attr', 'eq', key) | map(attribute='round') | first | default(1)
      %}\n        {% set ns.item = dict(ns.item, **{key: key_items | average | round(r)})
      %}\n      {% endif %}\n    {% endfor %}\n    {% set ns.forecast = ns.forecast
      + [ns.item] %}\n  {% endfor %}\n  {{ ns.forecast }}\n{% else %}\n  []\n{% endif
      %}\n"
- alias: Set variable for weather entities for attributes
  variables:
    weather_entities: "{{\n  states.weather\n    | map(attribute='entity_id')\n    |
      reject('in', integration_entities('template'))\n    | select('has_value')\n
      \   | list\n}}\n"
- alias: Send debug notification if debug mode is enabled
  if: '{{ debug | default(false) | bool(false) }}'
  then:
  - alias: Send notification with some debug date
    action: persistent_notification.create
    data:
      title: Weather Combined debug
      message: 'hourly: {{ hourly | count }} items

        hourly_entities: "{{ hourly_entities | join('', '') }}"

        daily: {{ daily | count }} items

        daily_entities: {{ daily_entities | join('', '') }}

        twice_daily: {{ twice_daily | count }} items

        twice_daily_entities: {{ twice_daily_entities | join('', '') }}

        '
weather:
  condition_template: "{% if weight is defined and weight is mapping %}\n  {% set
    ns = namespace(weight=[]) %}\n  {% for e in weather_entities %}\n    {% set w
    = weight.get(e, {}).get('current', 1) %}\n    {% set ns.weight = ns.weight + [states(e)]
    * w %}\n  {% endfor %}\n  {{ statistical_mode(ns.weight) }}\n{% else %}\n  {{
    expand(weather_entities)\n      | map(attribute='state')\n      | list\n      |
    statistical_mode(none)\n  }}\n{% endif %}\n"
  temperature_template: "{%- set attribute = 'temperature' %} {% if weight is defined
    and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in
    weather_entities %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {%
    set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n
    \ {{ median(ns.weight | select('is_number') | list, none) | round(1, default=none)
    }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  apparent_temperature_template: "{%- set attribute = 'apparent_temperature' %} {%
    if weight is defined and weight is mapping %}\n  {% set ns = namespace(weight=[])
    %}\n  {% for e in weather_entities %}\n    {% set w = weight.get(e, {}).get('current',
    1) %}\n    {% set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n
    \ {% endfor %}\n  {{ median(ns.weight | select('is_number') | list, none) | round(1,
    default=none) }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  pressure_template: "{%- set attribute = 'pressure' %} {% if weight is defined and
    weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in weather_entities
    %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {% set ns.weight
    = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n  {{ median(ns.weight
    | select('is_number') | list, none) | round(2, default=none) }}\n{% else %}\n
    \ {{\n    expand(weather_entities)\n      | selectattr('attributes.' ~ attribute,
    'defined')\n      | map(attribute='attributes.' ~ attribute)\n      | select('is_number')\n
    \     | list\n      | median(none)\n      | round(2, default=none)\n  }}\n{% endif
    %}\n"
  wind_speed_template: "{%- set attribute = 'wind_speed' %} {% if weight is defined
    and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in
    weather_entities %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {%
    set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n
    \ {{ median(ns.weight | select('is_number') | list, none) | round(1, default=none)
    }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  wind_gust_speed_template: "{%- set attribute = 'wind_gust_speed' %} {% if weight
    is defined and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {%
    for e in weather_entities %}\n    {% set w = weight.get(e, {}).get('current',
    1) %}\n    {% set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n
    \ {% endfor %}\n  {{ median(ns.weight | select('is_number') | list, none) | round(1,
    default=none) }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  visibility_template: "{%- set attribute = 'visibility' %} {% if weight is defined
    and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in
    weather_entities %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {%
    set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n
    \ {{ median(ns.weight | select('is_number') | list, none) | round(1, default=none)
    }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  humidity_template: "{%- set attribute = 'humidity' %} {% if weight is defined and
    weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in weather_entities
    %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {% set ns.weight
    = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n  {{ median(ns.weight
    | select('is_number') | list, none) | round(0, default=none) }}\n{% else %}\n
    \ {{\n    expand(weather_entities)\n      | selectattr('attributes.' ~ attribute,
    'defined')\n      | map(attribute='attributes.' ~ attribute)\n      | select('is_number')\n
    \     | list\n      | median(none)\n      | round(0, default=none)\n  }}\n{% endif
    %}\n"
  wind_bearing_template: "{%- set attribute = 'wind_bearing' %} {% if weight is defined
    and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in
    weather_entities %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {%
    set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n
    \ {{ median(ns.weight | select('is_number') | list, none) | round(1, default=none)
    }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  ozone_template: "{%- set attribute = 'ozone' %} {% if weight is defined and weight
    is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in weather_entities
    %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {% set ns.weight
    = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n  {{ median(ns.weight
    | select('is_number') | list, none) | round(2, default=none) }}\n{% else %}\n
    \ {{\n    expand(weather_entities)\n      | selectattr('attributes.' ~ attribute,
    'defined')\n      | map(attribute='attributes.' ~ attribute)\n      | select('is_number')\n
    \     | list\n      | median(none)\n      | round(2, default=none)\n  }}\n{% endif
    %}\n"
  cloud_coverage_template: "{%- set attribute = 'cloud_coverage' %} {% if weight is
    defined and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {%
    for e in weather_entities %}\n    {% set w = weight.get(e, {}).get('current',
    1) %}\n    {% set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n
    \ {% endfor %}\n  {{ median(ns.weight | select('is_number') | list, none) | round(0,
    default=none) }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(0, default=none)\n
    \ }}\n{% endif %}\n"
  dew_point_template: "{%- set attribute = 'dew_point' %} {% if weight is defined
    and weight is mapping %}\n  {% set ns = namespace(weight=[]) %}\n  {% for e in
    weather_entities %}\n    {% set w = weight.get(e, {}).get('current', 1) %}\n    {%
    set ns.weight = ns.weight + [state_attr(e, attribute)] * w %}\n  {% endfor %}\n
    \ {{ median(ns.weight | select('is_number') | list, none) | round(1, default=none)
    }}\n{% else %}\n  {{\n    expand(weather_entities)\n      | selectattr('attributes.'
    ~ attribute, 'defined')\n      | map(attribute='attributes.' ~ attribute)\n      |
    select('is_number')\n      | list\n      | median(none)\n      | round(1, default=none)\n
    \ }}\n{% endif %}\n"
  temperature_unit: !input temperature_unit
  pressure_unit: !input pressure_unit
  wind_speed_unit: !input wind_speed_unit
  visibility_unit: !input visibility_unit
  precipitation_unit: !input precipitation_unit
  forecast_hourly_template: '{{ hourly }}'
  forecast_daily_template: '{{ daily }}'
  forecast_twice_daily_template: '{{ twice_daily }}'
